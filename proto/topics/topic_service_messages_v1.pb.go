//
// Copyright (c) 2020, 2025, Oracle and/or its affiliates.
//
// Licensed under the Universal Permissive License v 1.0 as shown at
// https://oss.oracle.com/licenses/upl.

// -----------------------------------------------------------------
// Messages used by the Coherence gRPC NamedTopic Service.
//
// NOTE: If you add a new request message to this message the current
// protocol version in com.oracle.coherence.grpc.NamedTopicProtocol must
// be increased. This only needs to be done once for any given Coherence
// release.
// -----------------------------------------------------------------

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.19.2
// source: topic_service_messages_v1.proto

package topics

import (
	v1 "github.com/oracle/coherence-go-client/v2/proto/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	_ "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	_ "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// An enum representing the types of request for a Named Topic Service proxy
//
// NOTE: The index numbers for the enum elements MUST NOT BE CHANGED as
// that would break backwards compatibility. Only new index numbers can
// be added.
type TopicServiceRequestType int32

const (
	// An unknown message.
	// This request type is not used, it is here as enums must have a zero value,
	// but we need to know the difference between a zero value and the field being
	// incorrectly set.
	TopicServiceRequestType_RequestUnknown TopicServiceRequestType = 0
	// Called to ensure a topic.
	// Must be the first message called prior to any other topic requests.
	// The message field must be an EnsureTopicRequest.
	// The response will contain the Topic Id and an empty response field.
	TopicServiceRequestType_EnsureTopic TopicServiceRequestType = 1
	// Destroy the specified topic.
	// A destroy topic message must be sent with a proxy identifier of zero as it
	// is targeted at the topic service proxy.
	// The message field should be set to a StringValue containing the name of the topic to destroy.
	// The response will just be a Complete message corresponding to the request id.
	TopicServiceRequestType_DestroyTopic TopicServiceRequestType = 2
	// Called to get the channel count for a topic.
	// This message can be sent without ensuring the topic first and does not require
	// a topic id to be set. If the topic id is set then that will be used to identify
	// the topic to use, otherwise the topic name should be in the StringValue message.
	// If no topic id is set, the message field is a StringValue which is the name of the
	// topic to get the channel count for.
	// The response will be an Int32Value containing the channel count
	TopicServiceRequestType_GetChannelCount TopicServiceRequestType = 3
	// Get the durable subscriber groups for a topic
	// This message can be sent without ensuring the topic first and does not require
	// a topic id to be set. If the topic id is set then that will be used to identify
	// the topic to use, otherwise the topic name should be in the StringValue message.
	// If no topic id is set, the message field is a StringValue which is the name of the
	// topic to get the subscriber groups for.
	// The response will be a CollectionOfString message containing the names of the
	// subscriber groups.
	TopicServiceRequestType_GetSubscriberGroups TopicServiceRequestType = 4
	// Ensure that a topic has a specified number of channels
	// The message field should be an EnsureChannelCount message
	// The response wil be an Int32Value containing the topic channel count
	TopicServiceRequestType_EnsureChannelCount TopicServiceRequestType = 5
	// Ensure a subscriber group exists for a topic.
	// The message field should be an EnsureSubscriberGroupRequest message
	// The response will just be a Complete message corresponding to the request id.
	TopicServiceRequestType_EnsureSubscriberGroup TopicServiceRequestType = 6
	// Destroy a subscriber group.
	// The message field should be an StringValue containing the name of the
	// subscriber group to be destroyed
	// The response will just be a Complete message corresponding to the request id.
	TopicServiceRequestType_DestroySubscriberGroup TopicServiceRequestType = 7
	// Get a count of the remaining messages in a topic for a subscriber group.
	// The message field should be a GetRemainingMessagesRequest
	// The response will be an Int32Value containing the count of remaining messages.
	TopicServiceRequestType_GetRemainingMessages TopicServiceRequestType = 8
	// Get the tail positions for a topic
	// The response will be a MapOfChannelAndPosition with a position for each channel.
	TopicServiceRequestType_GetTails TopicServiceRequestType = 9
	// Called to ensure a publisher.
	// Must be the first message called prior to any other publisher requests.
	// The message field must be an EnsurePublisherRequest.
	// The response will contain the Publisher Id and an EnsurePublisherResponse response message.
	TopicServiceRequestType_EnsurePublisher TopicServiceRequestType = 10
	// Destroy the specified publisher.
	// The message field must be set to an Int32Value containing the publisher identifier
	// returned by the original ensure publisher request.
	// The response will just be a Complete message corresponding to the request id.
	TopicServiceRequestType_DestroyPublisher TopicServiceRequestType = 11
	// Publish values to a topic
	// The message field must be a PublishRequest
	// The response will be a PublishResult message
	TopicServiceRequestType_Publish TopicServiceRequestType = 12
	// Called to ensure a subscriber.
	// Must be the first message called prior to any other subscriber requests.
	// The message field must be an EnsureSubscriberRequest.
	// The response will contain the Subscriber Id and an EnsureSubscriberResponse
	// message in the response field.
	TopicServiceRequestType_EnsureSubscriber TopicServiceRequestType = 13
	// Destroy the specified subscriber.
	// The message field must be set to an Int32Value containing the subscriber identifier
	// returned by the original ensure subscriber request.
	// The response will just be a Complete message corresponding to the request id.
	TopicServiceRequestType_DestroySubscriber TopicServiceRequestType = 14
	// Initialize a subscriber connection
	// The message field should be an InitializeSubscriptionRequest message.
	// The response will be a InitializeSubscriptionResponse message.
	TopicServiceRequestType_InitializeSubscription TopicServiceRequestType = 15
	// Ensure a subscriber has a subscription to the topic.
	// The message field should be an EnsureSubscriptionRequest message.
	// The response will be a BoolValue indicating whether the subscription exists
	TopicServiceRequestType_EnsureSubscription TopicServiceRequestType = 16
	// Get the head positions for a subscriber
	// The message body should be a CollectionOfInt32 specifying the channels to
	// get the head positions for.
	// The response will be a MapOfChannelAndPosition with a position for each channel.
	TopicServiceRequestType_GetSubscriberHeads TopicServiceRequestType = 17
	// Get the last committed positions for a subscriber.
	// The message field should be empty.
	// The response will be a MapOfChannelAndPosition with a last committed position for each channel.
	TopicServiceRequestType_GetLastCommited TopicServiceRequestType = 18
	// Obtain the channels that are owned by a subscriber.
	// The message field should be empty.
	// The response will be a CollectionOfInt32 containing the owned channel identifiers.
	TopicServiceRequestType_GetOwnedChannels TopicServiceRequestType = 19
	// Send a heartbeat message for a subscriber.
	// The message contains a BoolValue indicating whether the heartbeat should
	// be sent asynchronously.
	TopicServiceRequestType_SubscriberHeartbeat TopicServiceRequestType = 20
	// Determine whether a position has been committed by a subscriber.
	// The message contains a ChannelAndPosition value.
	// The response will be a BoolValue indicating whether the position is committed.
	TopicServiceRequestType_IsPositionCommitted TopicServiceRequestType = 21
	// Peek at a value in a position.
	// The message contains a ChannelAndPosition value.
	// The response will be a TopicElement with the value from the position
	TopicServiceRequestType_PeekAtPosition TopicServiceRequestType = 22
	// Receive values from a topic.
	// The message should be a ReceiveRequest.
	// The response will be a ReceiveResponse.
	TopicServiceRequestType_Receive TopicServiceRequestType = 23
	// Seek a subscriber to a new position.
	// The message should be a SeekRequest.
	// The response will be a SeekResult.
	TopicServiceRequestType_SeekSubscriber TopicServiceRequestType = 24
	// Commit a channel and position
	// The message should be a ChannelAndPosition
	// The response will be a CommitResponse
	TopicServiceRequestType_CommitPosition TopicServiceRequestType = 25
)

// Enum value maps for TopicServiceRequestType.
var (
	TopicServiceRequestType_name = map[int32]string{
		0:  "RequestUnknown",
		1:  "EnsureTopic",
		2:  "DestroyTopic",
		3:  "GetChannelCount",
		4:  "GetSubscriberGroups",
		5:  "EnsureChannelCount",
		6:  "EnsureSubscriberGroup",
		7:  "DestroySubscriberGroup",
		8:  "GetRemainingMessages",
		9:  "GetTails",
		10: "EnsurePublisher",
		11: "DestroyPublisher",
		12: "Publish",
		13: "EnsureSubscriber",
		14: "DestroySubscriber",
		15: "InitializeSubscription",
		16: "EnsureSubscription",
		17: "GetSubscriberHeads",
		18: "GetLastCommited",
		19: "GetOwnedChannels",
		20: "SubscriberHeartbeat",
		21: "IsPositionCommitted",
		22: "PeekAtPosition",
		23: "Receive",
		24: "SeekSubscriber",
		25: "CommitPosition",
	}
	TopicServiceRequestType_value = map[string]int32{
		"RequestUnknown":         0,
		"EnsureTopic":            1,
		"DestroyTopic":           2,
		"GetChannelCount":        3,
		"GetSubscriberGroups":    4,
		"EnsureChannelCount":     5,
		"EnsureSubscriberGroup":  6,
		"DestroySubscriberGroup": 7,
		"GetRemainingMessages":   8,
		"GetTails":               9,
		"EnsurePublisher":        10,
		"DestroyPublisher":       11,
		"Publish":                12,
		"EnsureSubscriber":       13,
		"DestroySubscriber":      14,
		"InitializeSubscription": 15,
		"EnsureSubscription":     16,
		"GetSubscriberHeads":     17,
		"GetLastCommited":        18,
		"GetOwnedChannels":       19,
		"SubscriberHeartbeat":    20,
		"IsPositionCommitted":    21,
		"PeekAtPosition":         22,
		"Receive":                23,
		"SeekSubscriber":         24,
		"CommitPosition":         25,
	}
)

func (x TopicServiceRequestType) Enum() *TopicServiceRequestType {
	p := new(TopicServiceRequestType)
	*p = x
	return p
}

func (x TopicServiceRequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TopicServiceRequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[0].Descriptor()
}

func (TopicServiceRequestType) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[0]
}

func (x TopicServiceRequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TopicServiceRequestType.Descriptor instead.
func (TopicServiceRequestType) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{0}
}

// An enum representing different types of response.
//
// NOTE: The index numbers for the enum elements MUST NOT BE CHANGED as
// that would break backwards compatibility. Only new index numbers can
// be added.
type ResponseType int32

const (
	// The response is a message.
	ResponseType_Message ResponseType = 0
	// The response is a map event.
	ResponseType_Event ResponseType = 1
)

// Enum value maps for ResponseType.
var (
	ResponseType_name = map[int32]string{
		0: "Message",
		1: "Event",
	}
	ResponseType_value = map[string]int32{
		"Message": 0,
		"Event":   1,
	}
)

func (x ResponseType) Enum() *ResponseType {
	p := new(ResponseType)
	*p = x
	return p
}

func (x ResponseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResponseType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[1].Descriptor()
}

func (ResponseType) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[1]
}

func (x ResponseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResponseType.Descriptor instead.
func (ResponseType) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{1}
}

type TopicEventType int32

const (
	// An unknown type.
	// This request type is not used, it is here as enums must have a zero value,
	// but we need to know the difference between a zero value and the field being
	// incorrectly set.
	TopicEventType_EventUnknown TopicEventType = 0
	// The topic has been destroyed
	TopicEventType_TopicDestroyed TopicEventType = 1
)

// Enum value maps for TopicEventType.
var (
	TopicEventType_name = map[int32]string{
		0: "EventUnknown",
		1: "TopicDestroyed",
	}
	TopicEventType_value = map[string]int32{
		"EventUnknown":   0,
		"TopicDestroyed": 1,
	}
)

func (x TopicEventType) Enum() *TopicEventType {
	p := new(TopicEventType)
	*p = x
	return p
}

func (x TopicEventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (TopicEventType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[2].Descriptor()
}

func (TopicEventType) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[2]
}

func (x TopicEventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use TopicEventType.Descriptor instead.
func (TopicEventType) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{2}
}

// The types for a publisher event.
type PublisherEventType int32

const (
	// An unknown type.
	// This request type is not used, it is here as enums must have a zero value,
	// but we need to know the difference between a zero value and the field being
	// incorrectly set.
	PublisherEventType_PublisherEventUnknown PublisherEventType = 0
	// The publisher has connected.
	PublisherEventType_PublisherConnected PublisherEventType = 1
	// The publisher has disconnected.
	PublisherEventType_PublisherDisconnected PublisherEventType = 2
	// A previously full topic now has space
	PublisherEventType_PublisherChannelsFreed PublisherEventType = 3
	// The topic the publisher publishes to has been destroyed.
	PublisherEventType_PublisherDestroyed PublisherEventType = 4
	// The topic the publisher publishes to has been released.
	PublisherEventType_PublisherReleased PublisherEventType = 5
)

// Enum value maps for PublisherEventType.
var (
	PublisherEventType_name = map[int32]string{
		0: "PublisherEventUnknown",
		1: "PublisherConnected",
		2: "PublisherDisconnected",
		3: "PublisherChannelsFreed",
		4: "PublisherDestroyed",
		5: "PublisherReleased",
	}
	PublisherEventType_value = map[string]int32{
		"PublisherEventUnknown":  0,
		"PublisherConnected":     1,
		"PublisherDisconnected":  2,
		"PublisherChannelsFreed": 3,
		"PublisherDestroyed":     4,
		"PublisherReleased":      5,
	}
)

func (x PublisherEventType) Enum() *PublisherEventType {
	p := new(PublisherEventType)
	*p = x
	return p
}

func (x PublisherEventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PublisherEventType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[3].Descriptor()
}

func (PublisherEventType) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[3]
}

func (x PublisherEventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PublisherEventType.Descriptor instead.
func (PublisherEventType) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{3}
}

type PublishStatus int32

const (
	// The offer invocation was successful and all elements were
	// accepted into the page.
	PublishStatus_Success PublishStatus = 0
	// The offer invocation was unsuccessful as the topic was full.
	// The offer may have been partially successful if multiple elements
	// had been offered.
	// The publisher should wait for a PublisherEvent of type
	PublishStatus_TopicFull PublishStatus = 1
)

// Enum value maps for PublishStatus.
var (
	PublishStatus_name = map[int32]string{
		0: "Success",
		1: "TopicFull",
	}
	PublishStatus_value = map[string]int32{
		"Success":   0,
		"TopicFull": 1,
	}
)

func (x PublishStatus) Enum() *PublishStatus {
	p := new(PublishStatus)
	*p = x
	return p
}

func (x PublishStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PublishStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[4].Descriptor()
}

func (PublishStatus) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[4]
}

func (x PublishStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PublishStatus.Descriptor instead.
func (PublishStatus) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{4}
}

type SubscriberEventType int32

const (
	// An unknown type.
	// This request type is not used, it is here as enums must have a zero value,
	// but we need to know the difference between a zero value and the field being
	// incorrectly set.
	SubscriberEventType_SubscriberEventUnknown SubscriberEventType = 0
	// The event indicates the subscriber group was destroyed.
	SubscriberEventType_SubscriberGroupDestroyed SubscriberEventType = 1
	// The event is a channel allocation event.
	SubscriberEventType_SubscriberChannelAllocation SubscriberEventType = 2
	// The event is a channels lost event.
	SubscriberEventType_SubscriberChannelsLost SubscriberEventType = 3
	// The event is a channel populated event.
	SubscriberEventType_SubscriberChannelPopulated SubscriberEventType = 4
	// The head position of a channel has changed
	SubscriberEventType_SubscriberChannelHead SubscriberEventType = 5
	// The event is an unsubscribed event.
	SubscriberEventType_SubscriberUnsubscribed SubscriberEventType = 6
	// The parent topic was destroyed.
	SubscriberEventType_SubscriberDestroyed SubscriberEventType = 7
	// The parent topic was released.
	SubscriberEventType_SubscriberReleased SubscriberEventType = 8
	// The subscriber was disconnected.
	SubscriberEventType_SubscriberDisconnected SubscriberEventType = 9
)

// Enum value maps for SubscriberEventType.
var (
	SubscriberEventType_name = map[int32]string{
		0: "SubscriberEventUnknown",
		1: "SubscriberGroupDestroyed",
		2: "SubscriberChannelAllocation",
		3: "SubscriberChannelsLost",
		4: "SubscriberChannelPopulated",
		5: "SubscriberChannelHead",
		6: "SubscriberUnsubscribed",
		7: "SubscriberDestroyed",
		8: "SubscriberReleased",
		9: "SubscriberDisconnected",
	}
	SubscriberEventType_value = map[string]int32{
		"SubscriberEventUnknown":      0,
		"SubscriberGroupDestroyed":    1,
		"SubscriberChannelAllocation": 2,
		"SubscriberChannelsLost":      3,
		"SubscriberChannelPopulated":  4,
		"SubscriberChannelHead":       5,
		"SubscriberUnsubscribed":      6,
		"SubscriberDestroyed":         7,
		"SubscriberReleased":          8,
		"SubscriberDisconnected":      9,
	}
)

func (x SubscriberEventType) Enum() *SubscriberEventType {
	p := new(SubscriberEventType)
	*p = x
	return p
}

func (x SubscriberEventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SubscriberEventType) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[5].Descriptor()
}

func (SubscriberEventType) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[5]
}

func (x SubscriberEventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SubscriberEventType.Descriptor instead.
func (SubscriberEventType) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{5}
}

// The status of a receive response.
type ReceiveStatus int32

const (
	// The receive request was successful.
	ReceiveStatus_ReceiveSuccess ReceiveStatus = 0
	// The channel was exhausted.
	ReceiveStatus_ChannelExhausted ReceiveStatus = 1
	// The channel was not allocated to the subscriber.
	ReceiveStatus_ChannelNotAllocatedChannel ReceiveStatus = 2
	// The server did not recognise the subscriber
	ReceiveStatus_UnknownSubscriber ReceiveStatus = 3
)

// Enum value maps for ReceiveStatus.
var (
	ReceiveStatus_name = map[int32]string{
		0: "ReceiveSuccess",
		1: "ChannelExhausted",
		2: "ChannelNotAllocatedChannel",
		3: "UnknownSubscriber",
	}
	ReceiveStatus_value = map[string]int32{
		"ReceiveSuccess":             0,
		"ChannelExhausted":           1,
		"ChannelNotAllocatedChannel": 2,
		"UnknownSubscriber":          3,
	}
)

func (x ReceiveStatus) Enum() *ReceiveStatus {
	p := new(ReceiveStatus)
	*p = x
	return p
}

func (x ReceiveStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReceiveStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[6].Descriptor()
}

func (ReceiveStatus) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[6]
}

func (x ReceiveStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReceiveStatus.Descriptor instead.
func (ReceiveStatus) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{6}
}

// The different result statuses for a commit request.
type CommitResponseStatus int32

const (
	// The position was successfully committed.
	CommitResponseStatus_Committed CommitResponseStatus = 0
	// The position was already committed.
	// Typically, this is caused by a commit of a higher position in the channel
	// already being processed.
	CommitResponseStatus_AlreadyCommitted CommitResponseStatus = 1
	// The commit request was rejected.
	CommitResponseStatus_Rejected CommitResponseStatus = 2
	// The position was successfully committed but the committing subscriber
	// does not own the committed channel.
	CommitResponseStatus_Unowned CommitResponseStatus = 3
	// A commit request was made, but there was no position to be committed.
	CommitResponseStatus_NothingToCommit CommitResponseStatus = 4
)

// Enum value maps for CommitResponseStatus.
var (
	CommitResponseStatus_name = map[int32]string{
		0: "Committed",
		1: "AlreadyCommitted",
		2: "Rejected",
		3: "Unowned",
		4: "NothingToCommit",
	}
	CommitResponseStatus_value = map[string]int32{
		"Committed":        0,
		"AlreadyCommitted": 1,
		"Rejected":         2,
		"Unowned":          3,
		"NothingToCommit":  4,
	}
)

func (x CommitResponseStatus) Enum() *CommitResponseStatus {
	p := new(CommitResponseStatus)
	*p = x
	return p
}

func (x CommitResponseStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CommitResponseStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_topic_service_messages_v1_proto_enumTypes[7].Descriptor()
}

func (CommitResponseStatus) Type() protoreflect.EnumType {
	return &file_topic_service_messages_v1_proto_enumTypes[7]
}

func (x CommitResponseStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CommitResponseStatus.Descriptor instead.
func (CommitResponseStatus) EnumDescriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{7}
}

// A request to perform an operation on a remote NamedTopic.
type TopicServiceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the request
	Type TopicServiceRequestType `protobuf:"varint,1,opt,name=type,proto3,enum=coherence.topic.v1.TopicServiceRequestType" json:"type,omitempty"`
	// The topic identifier for the request.
	// The identifier must be the same value returned by the initial ensure request.
	// This is optional only for EnsureTopic as this cannot have a topic identifier
	ProxyId *int32 `protobuf:"varint,2,opt,name=proxyId,proto3,oneof" json:"proxyId,omitempty"`
	// The actual request message, this is optional because some messages do not require
	// a message body, for example topic.size()
	// The actual request message should be packed inside an Any message and set in this field.
	// The proxy will know which message type to expect here based on the "type" field's value.
	Message       *anypb.Any `protobuf:"bytes,3,opt,name=message,proto3,oneof" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicServiceRequest) Reset() {
	*x = TopicServiceRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicServiceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicServiceRequest) ProtoMessage() {}

func (x *TopicServiceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicServiceRequest.ProtoReflect.Descriptor instead.
func (*TopicServiceRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{0}
}

func (x *TopicServiceRequest) GetType() TopicServiceRequestType {
	if x != nil {
		return x.Type
	}
	return TopicServiceRequestType_RequestUnknown
}

func (x *TopicServiceRequest) GetProxyId() int32 {
	if x != nil && x.ProxyId != nil {
		return *x.ProxyId
	}
	return 0
}

func (x *TopicServiceRequest) GetMessage() *anypb.Any {
	if x != nil {
		return x.Message
	}
	return nil
}

// A response message from a Named Topic Service proxy.
//
// NOTE: If you add a new request message to this message the protocol
// version in com.oracle.coherence.grpc.NamedTopicProtocol must be
// increased. This only needs to be done once for any given Coherence
// release.
type TopicServiceResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The proxy identifier for the response
	ProxyId int32 `protobuf:"varint,1,opt,name=proxyId,proto3" json:"proxyId,omitempty"`
	// An enum representing different response types.
	// The type of the request.
	Type ResponseType `protobuf:"varint,2,opt,name=type,proto3,enum=coherence.topic.v1.ResponseType" json:"type,omitempty"`
	// The response can contain one of a number of response types
	// The sender of the corresponding request should know which
	// response type it expects
	Message       *anypb.Any `protobuf:"bytes,3,opt,name=message,proto3,oneof" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicServiceResponse) Reset() {
	*x = TopicServiceResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicServiceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicServiceResponse) ProtoMessage() {}

func (x *TopicServiceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicServiceResponse.ProtoReflect.Descriptor instead.
func (*TopicServiceResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{1}
}

func (x *TopicServiceResponse) GetProxyId() int32 {
	if x != nil {
		return x.ProxyId
	}
	return 0
}

func (x *TopicServiceResponse) GetType() ResponseType {
	if x != nil {
		return x.Type
	}
	return ResponseType_Message
}

func (x *TopicServiceResponse) GetMessage() *anypb.Any {
	if x != nil {
		return x.Message
	}
	return nil
}

// A request to ensure a specific topic.
type EnsureTopicRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the topic.
	Topic         string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureTopicRequest) Reset() {
	*x = EnsureTopicRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureTopicRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureTopicRequest) ProtoMessage() {}

func (x *EnsureTopicRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureTopicRequest.ProtoReflect.Descriptor instead.
func (*EnsureTopicRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{2}
}

func (x *EnsureTopicRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

// An event to indicate the state of a NamedTopic has changed.
type NamedTopicEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the event.
	Type          TopicEventType `protobuf:"varint,1,opt,name=type,proto3,enum=coherence.topic.v1.TopicEventType" json:"type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NamedTopicEvent) Reset() {
	*x = NamedTopicEvent{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NamedTopicEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NamedTopicEvent) ProtoMessage() {}

func (x *NamedTopicEvent) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NamedTopicEvent.ProtoReflect.Descriptor instead.
func (*NamedTopicEvent) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{3}
}

func (x *NamedTopicEvent) GetType() TopicEventType {
	if x != nil {
		return x.Type
	}
	return TopicEventType_EventUnknown
}

// Ensure that a topic has a specified number of channels.
type EnsureChannelCountRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the name of the topic if this message is sent without a topic id
	Topic *string `protobuf:"bytes,1,opt,name=topic,proto3,oneof" json:"topic,omitempty"`
	// the required number of channels
	RequiredCount int32 `protobuf:"varint,2,opt,name=requiredCount,proto3" json:"requiredCount,omitempty"`
	// the number of channels to create if the actual count is less
	// than the requiredCount
	ChannelCount  *int32 `protobuf:"varint,3,opt,name=channelCount,proto3,oneof" json:"channelCount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureChannelCountRequest) Reset() {
	*x = EnsureChannelCountRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureChannelCountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureChannelCountRequest) ProtoMessage() {}

func (x *EnsureChannelCountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureChannelCountRequest.ProtoReflect.Descriptor instead.
func (*EnsureChannelCountRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{4}
}

func (x *EnsureChannelCountRequest) GetTopic() string {
	if x != nil && x.Topic != nil {
		return *x.Topic
	}
	return ""
}

func (x *EnsureChannelCountRequest) GetRequiredCount() int32 {
	if x != nil {
		return x.RequiredCount
	}
	return 0
}

func (x *EnsureChannelCountRequest) GetChannelCount() int32 {
	if x != nil && x.ChannelCount != nil {
		return *x.ChannelCount
	}
	return 0
}

// A request to ensure a subscriber group exists for a topic.
type EnsureSubscriberGroupRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the name of the subscriber group
	SubscriberGroup string `protobuf:"bytes,2,opt,name=subscriberGroup,proto3" json:"subscriberGroup,omitempty"`
	// an optional Filter to filter received messages
	Filter []byte `protobuf:"bytes,3,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
	// an optional ValueExtractor to convert received messages
	Extractor     []byte `protobuf:"bytes,4,opt,name=extractor,proto3,oneof" json:"extractor,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureSubscriberGroupRequest) Reset() {
	*x = EnsureSubscriberGroupRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureSubscriberGroupRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureSubscriberGroupRequest) ProtoMessage() {}

func (x *EnsureSubscriberGroupRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureSubscriberGroupRequest.ProtoReflect.Descriptor instead.
func (*EnsureSubscriberGroupRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{5}
}

func (x *EnsureSubscriberGroupRequest) GetSubscriberGroup() string {
	if x != nil {
		return x.SubscriberGroup
	}
	return ""
}

func (x *EnsureSubscriberGroupRequest) GetFilter() []byte {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *EnsureSubscriberGroupRequest) GetExtractor() []byte {
	if x != nil {
		return x.Extractor
	}
	return nil
}

// Get a count of the remaining messages in a topic for a subscriber group.
type GetRemainingMessagesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// the name of the topic if this message is sent without a topic id
	Topic *string `protobuf:"bytes,1,opt,name=topic,proto3,oneof" json:"topic,omitempty"`
	// The subscriber group to obtain the remaining message counts for
	SubscriberGroup string `protobuf:"bytes,2,opt,name=subscriberGroup,proto3" json:"subscriberGroup,omitempty"`
	// The channels to obtain the remaining message count for.
	// An empty channel set will return all channels.
	Channels      []int32 `protobuf:"varint,3,rep,packed,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRemainingMessagesRequest) Reset() {
	*x = GetRemainingMessagesRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRemainingMessagesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRemainingMessagesRequest) ProtoMessage() {}

func (x *GetRemainingMessagesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRemainingMessagesRequest.ProtoReflect.Descriptor instead.
func (*GetRemainingMessagesRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{6}
}

func (x *GetRemainingMessagesRequest) GetTopic() string {
	if x != nil && x.Topic != nil {
		return *x.Topic
	}
	return ""
}

func (x *GetRemainingMessagesRequest) GetSubscriberGroup() string {
	if x != nil {
		return x.SubscriberGroup
	}
	return ""
}

func (x *GetRemainingMessagesRequest) GetChannels() []int32 {
	if x != nil {
		return x.Channels
	}
	return nil
}

// A request to ensure a specific publisher.
type EnsurePublisherRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the topic.
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// The number of channels the publisher requires
	ChannelCount  int32 `protobuf:"varint,2,opt,name=channelCount,proto3" json:"channelCount,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsurePublisherRequest) Reset() {
	*x = EnsurePublisherRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsurePublisherRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsurePublisherRequest) ProtoMessage() {}

func (x *EnsurePublisherRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsurePublisherRequest.ProtoReflect.Descriptor instead.
func (*EnsurePublisherRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{7}
}

func (x *EnsurePublisherRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *EnsurePublisherRequest) GetChannelCount() int32 {
	if x != nil {
		return x.ChannelCount
	}
	return 0
}

// The response message sent as a result of an EnsurePublisher request.
type EnsurePublisherResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The publisher proxy identifier
	ProxyId int32 `protobuf:"varint,1,opt,name=proxyId,proto3" json:"proxyId,omitempty"`
	// The identifier of the publisher
	PublisherId int64 `protobuf:"varint,2,opt,name=publisherId,proto3" json:"publisherId,omitempty"`
	// The number of channels the topic has.
	ChannelCount int32 `protobuf:"varint,3,opt,name=channelCount,proto3" json:"channelCount,omitempty"`
	// The maximum batch size before the publisher is throttled
	MaxBatchSize  int64 `protobuf:"varint,4,opt,name=maxBatchSize,proto3" json:"maxBatchSize,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsurePublisherResponse) Reset() {
	*x = EnsurePublisherResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsurePublisherResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsurePublisherResponse) ProtoMessage() {}

func (x *EnsurePublisherResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsurePublisherResponse.ProtoReflect.Descriptor instead.
func (*EnsurePublisherResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{8}
}

func (x *EnsurePublisherResponse) GetProxyId() int32 {
	if x != nil {
		return x.ProxyId
	}
	return 0
}

func (x *EnsurePublisherResponse) GetPublisherId() int64 {
	if x != nil {
		return x.PublisherId
	}
	return 0
}

func (x *EnsurePublisherResponse) GetChannelCount() int32 {
	if x != nil {
		return x.ChannelCount
	}
	return 0
}

func (x *EnsurePublisherResponse) GetMaxBatchSize() int64 {
	if x != nil {
		return x.MaxBatchSize
	}
	return 0
}

// An event to indicate the state of a NamedTopic Publisher has changed.
type PublisherEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the event.
	Type PublisherEventType `protobuf:"varint,1,opt,name=type,proto3,enum=coherence.topic.v1.PublisherEventType" json:"type,omitempty"`
	// The channels the event relates to.
	Channels      []int32 `protobuf:"varint,2,rep,packed,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublisherEvent) Reset() {
	*x = PublisherEvent{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublisherEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublisherEvent) ProtoMessage() {}

func (x *PublisherEvent) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublisherEvent.ProtoReflect.Descriptor instead.
func (*PublisherEvent) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{9}
}

func (x *PublisherEvent) GetType() PublisherEventType {
	if x != nil {
		return x.Type
	}
	return PublisherEventType_PublisherEventUnknown
}

func (x *PublisherEvent) GetChannels() []int32 {
	if x != nil {
		return x.Channels
	}
	return nil
}

// A request to publish values to a channel in a topic
// using a previously ensured publisher.
type PublishRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The channel to publish to
	Channel int32 `protobuf:"varint,2,opt,name=channel,proto3" json:"channel,omitempty"`
	// The serialized values to publish.
	Values [][]byte `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	// The identifier used to register for notifications
	// if the topic is full.
	// This is used by the Coherence Java client and can be safely
	// ignored in other implementations.
	NotificationIdentifier *int32 `protobuf:"varint,4,opt,name=notificationIdentifier,proto3,oneof" json:"notificationIdentifier,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *PublishRequest) Reset() {
	*x = PublishRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishRequest) ProtoMessage() {}

func (x *PublishRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishRequest.ProtoReflect.Descriptor instead.
func (*PublishRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{10}
}

func (x *PublishRequest) GetChannel() int32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *PublishRequest) GetValues() [][]byte {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *PublishRequest) GetNotificationIdentifier() int32 {
	if x != nil && x.NotificationIdentifier != nil {
		return *x.NotificationIdentifier
	}
	return 0
}

// The status of a published value.
type PublishedValueStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to State:
	//
	//	*PublishedValueStatus_Position
	//	*PublishedValueStatus_Error
	State         isPublishedValueStatus_State `protobuf_oneof:"state"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishedValueStatus) Reset() {
	*x = PublishedValueStatus{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishedValueStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishedValueStatus) ProtoMessage() {}

func (x *PublishedValueStatus) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishedValueStatus.ProtoReflect.Descriptor instead.
func (*PublishedValueStatus) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{11}
}

func (x *PublishedValueStatus) GetState() isPublishedValueStatus_State {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *PublishedValueStatus) GetPosition() *TopicPosition {
	if x != nil {
		if x, ok := x.State.(*PublishedValueStatus_Position); ok {
			return x.Position
		}
	}
	return nil
}

func (x *PublishedValueStatus) GetError() *v1.ErrorMessage {
	if x != nil {
		if x, ok := x.State.(*PublishedValueStatus_Error); ok {
			return x.Error
		}
	}
	return nil
}

type isPublishedValueStatus_State interface {
	isPublishedValueStatus_State()
}

type PublishedValueStatus_Position struct {
	// An opaque representation of the position the element was published to
	Position *TopicPosition `protobuf:"bytes,1,opt,name=position,proto3,oneof"`
}

type PublishedValueStatus_Error struct {
	// Any error that may have occurred, in which case the value was not published.
	Error *v1.ErrorMessage `protobuf:"bytes,2,opt,name=error,proto3,oneof"`
}

func (*PublishedValueStatus_Position) isPublishedValueStatus_State() {}

func (*PublishedValueStatus_Error) isPublishedValueStatus_State() {}

// The result of publishing values to a topic.
type PublishResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The channel published to.
	Channel int32 `protobuf:"varint,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The result status.
	Status PublishStatus `protobuf:"varint,3,opt,name=status,proto3,enum=coherence.topic.v1.PublishStatus" json:"status,omitempty"`
	// The number of values that were successfully published.
	AcceptedCount int32 `protobuf:"varint,5,opt,name=acceptedCount,proto3" json:"acceptedCount,omitempty"`
	// The remaining capacity.
	RemainingCapacity int32 `protobuf:"varint,6,opt,name=remainingCapacity,proto3" json:"remainingCapacity,omitempty"`
	// A status for each of the published values.
	ValueStatus   []*PublishedValueStatus `protobuf:"bytes,7,rep,name=valueStatus,proto3" json:"valueStatus,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishResult) Reset() {
	*x = PublishResult{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishResult) ProtoMessage() {}

func (x *PublishResult) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishResult.ProtoReflect.Descriptor instead.
func (*PublishResult) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{12}
}

func (x *PublishResult) GetChannel() int32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *PublishResult) GetStatus() PublishStatus {
	if x != nil {
		return x.Status
	}
	return PublishStatus_Success
}

func (x *PublishResult) GetAcceptedCount() int32 {
	if x != nil {
		return x.AcceptedCount
	}
	return 0
}

func (x *PublishResult) GetRemainingCapacity() int32 {
	if x != nil {
		return x.RemainingCapacity
	}
	return 0
}

func (x *PublishResult) GetValueStatus() []*PublishedValueStatus {
	if x != nil {
		return x.ValueStatus
	}
	return nil
}

// A position within a paged topic.
type PagedPosition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The page identifier.
	Page int64 `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty"`
	// The offset within a page
	Offset        int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PagedPosition) Reset() {
	*x = PagedPosition{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PagedPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PagedPosition) ProtoMessage() {}

func (x *PagedPosition) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PagedPosition.ProtoReflect.Descriptor instead.
func (*PagedPosition) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{13}
}

func (x *PagedPosition) GetPage() int64 {
	if x != nil {
		return x.Page
	}
	return 0
}

func (x *PagedPosition) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// An opaque topic position
type TopicPosition struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Position      *anypb.Any             `protobuf:"bytes,1,opt,name=position,proto3" json:"position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicPosition) Reset() {
	*x = TopicPosition{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicPosition) ProtoMessage() {}

func (x *TopicPosition) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicPosition.ProtoReflect.Descriptor instead.
func (*TopicPosition) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{14}
}

func (x *TopicPosition) GetPosition() *anypb.Any {
	if x != nil {
		return x.Position
	}
	return nil
}

// The response to an EnsureSubscriberRequest
type EnsureSubscriberResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The publisher proxy identifier
	ProxyId int32 `protobuf:"varint,1,opt,name=proxyId,proto3" json:"proxyId,omitempty"`
	// The unique server side subscriber identifier.
	SubscriberId *SubscriberId `protobuf:"bytes,2,opt,name=subscriberId,proto3" json:"subscriberId,omitempty"`
	// The subscribers group identifier
	GroupId       *SubscriberGroupId `protobuf:"bytes,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureSubscriberResponse) Reset() {
	*x = EnsureSubscriberResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureSubscriberResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureSubscriberResponse) ProtoMessage() {}

func (x *EnsureSubscriberResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureSubscriberResponse.ProtoReflect.Descriptor instead.
func (*EnsureSubscriberResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{15}
}

func (x *EnsureSubscriberResponse) GetProxyId() int32 {
	if x != nil {
		return x.ProxyId
	}
	return 0
}

func (x *EnsureSubscriberResponse) GetSubscriberId() *SubscriberId {
	if x != nil {
		return x.SubscriberId
	}
	return nil
}

func (x *EnsureSubscriberResponse) GetGroupId() *SubscriberGroupId {
	if x != nil {
		return x.GroupId
	}
	return nil
}

// A request to ensure a specific subscriber.
type EnsureSubscriberRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the topic.
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// the optional name of the subscriber group
	SubscriberGroup *string `protobuf:"bytes,2,opt,name=subscriberGroup,proto3,oneof" json:"subscriberGroup,omitempty"`
	// an optional Filter to filter received messages
	Filter []byte `protobuf:"bytes,3,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
	// an optional ValueExtractor to convert received messages
	Extractor []byte `protobuf:"bytes,4,opt,name=extractor,proto3,oneof" json:"extractor,omitempty"`
	// True to return an empty value if the topic is empty
	CompleteOnEmpty bool `protobuf:"varint,5,opt,name=completeOnEmpty,proto3" json:"completeOnEmpty,omitempty"`
	// The channels to allocate to this subscriber (invalid channels will be ignored)
	Channels      []int32 `protobuf:"varint,6,rep,packed,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureSubscriberRequest) Reset() {
	*x = EnsureSubscriberRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureSubscriberRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureSubscriberRequest) ProtoMessage() {}

func (x *EnsureSubscriberRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureSubscriberRequest.ProtoReflect.Descriptor instead.
func (*EnsureSubscriberRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{16}
}

func (x *EnsureSubscriberRequest) GetTopic() string {
	if x != nil {
		return x.Topic
	}
	return ""
}

func (x *EnsureSubscriberRequest) GetSubscriberGroup() string {
	if x != nil && x.SubscriberGroup != nil {
		return *x.SubscriberGroup
	}
	return ""
}

func (x *EnsureSubscriberRequest) GetFilter() []byte {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *EnsureSubscriberRequest) GetExtractor() []byte {
	if x != nil {
		return x.Extractor
	}
	return nil
}

func (x *EnsureSubscriberRequest) GetCompleteOnEmpty() bool {
	if x != nil {
		return x.CompleteOnEmpty
	}
	return false
}

func (x *EnsureSubscriberRequest) GetChannels() []int32 {
	if x != nil {
		return x.Channels
	}
	return nil
}

// An event to indicate the state of a NamedTopic Subscriber has changed.
type SubscriberEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the event.
	Type SubscriberEventType `protobuf:"varint,1,opt,name=type,proto3,enum=coherence.topic.v1.SubscriberEventType" json:"type,omitempty"`
	// The channels associated with the event
	Channels      []int32 `protobuf:"varint,2,rep,packed,name=channels,proto3" json:"channels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscriberEvent) Reset() {
	*x = SubscriberEvent{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscriberEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscriberEvent) ProtoMessage() {}

func (x *SubscriberEvent) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscriberEvent.ProtoReflect.Descriptor instead.
func (*SubscriberEvent) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{17}
}

func (x *SubscriberEvent) GetType() SubscriberEventType {
	if x != nil {
		return x.Type
	}
	return SubscriberEventType_SubscriberEventUnknown
}

func (x *SubscriberEvent) GetChannels() []int32 {
	if x != nil {
		return x.Channels
	}
	return nil
}

// The unique identifier for a subscriber.
type SubscriberId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The subscriber identifier.
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The owning member UUID.
	Uuid          []byte `protobuf:"bytes,4,opt,name=uuid,proto3" json:"uuid,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscriberId) Reset() {
	*x = SubscriberId{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscriberId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscriberId) ProtoMessage() {}

func (x *SubscriberId) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscriberId.ProtoReflect.Descriptor instead.
func (*SubscriberId) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{18}
}

func (x *SubscriberId) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *SubscriberId) GetUuid() []byte {
	if x != nil {
		return x.Uuid
	}
	return nil
}

// An identifier for a subscriber group
type SubscriberGroupId struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The subscriber group name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The subscriber group identifier
	Id            int64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscriberGroupId) Reset() {
	*x = SubscriberGroupId{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscriberGroupId) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscriberGroupId) ProtoMessage() {}

func (x *SubscriberGroupId) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscriberGroupId.ProtoReflect.Descriptor instead.
func (*SubscriberGroupId) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{19}
}

func (x *SubscriberGroupId) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *SubscriberGroupId) GetId() int64 {
	if x != nil {
		return x.Id
	}
	return 0
}

// Initialize the subscriber connection.
type InitializeSubscriptionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A flag to indicate if the subscriber was initially disconnected.
	Disconnected bool `protobuf:"varint,1,opt,name=disconnected,proto3" json:"disconnected,omitempty"`
	// This is a reconnection of an existing subscriber
	Reconnect bool `protobuf:"varint,2,opt,name=reconnect,proto3" json:"reconnect,omitempty"`
	// A flag to indicate that the reconnect logic should force a reconnect
	// request even if the subscriber is in the config map
	ForceReconnect bool `protobuf:"varint,3,opt,name=forceReconnect,proto3" json:"forceReconnect,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *InitializeSubscriptionRequest) Reset() {
	*x = InitializeSubscriptionRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeSubscriptionRequest) ProtoMessage() {}

func (x *InitializeSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*InitializeSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{20}
}

func (x *InitializeSubscriptionRequest) GetDisconnected() bool {
	if x != nil {
		return x.Disconnected
	}
	return false
}

func (x *InitializeSubscriptionRequest) GetReconnect() bool {
	if x != nil {
		return x.Reconnect
	}
	return false
}

func (x *InitializeSubscriptionRequest) GetForceReconnect() bool {
	if x != nil {
		return x.ForceReconnect
	}
	return false
}

// A response to an initialize subscriber request.
type InitializeSubscriptionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifier for the subscribers current subscription.
	SubscriptionId int64 `protobuf:"varint,1,opt,name=subscriptionId,proto3" json:"subscriptionId,omitempty"`
	// The subscribers connection timestamp
	Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The head positions of the topic channels
	Heads         []*TopicPosition `protobuf:"bytes,3,rep,name=heads,proto3" json:"heads,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InitializeSubscriptionResponse) Reset() {
	*x = InitializeSubscriptionResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InitializeSubscriptionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InitializeSubscriptionResponse) ProtoMessage() {}

func (x *InitializeSubscriptionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InitializeSubscriptionResponse.ProtoReflect.Descriptor instead.
func (*InitializeSubscriptionResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{21}
}

func (x *InitializeSubscriptionResponse) GetSubscriptionId() int64 {
	if x != nil {
		return x.SubscriptionId
	}
	return 0
}

func (x *InitializeSubscriptionResponse) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *InitializeSubscriptionResponse) GetHeads() []*TopicPosition {
	if x != nil {
		return x.Heads
	}
	return nil
}

// Ensure a subscriber has a subscription in the topic.
type EnsureSubscriptionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The identifier for the subscribers current subscription.
	SubscriptionId int64 `protobuf:"varint,1,opt,name=subscriptionId,proto3" json:"subscriptionId,omitempty"`
	// A flag to indicate that the reconnect logic should force a reconnect
	// request even if the subscriber is in the config map
	ForceReconnect bool `protobuf:"varint,2,opt,name=forceReconnect,proto3" json:"forceReconnect,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *EnsureSubscriptionRequest) Reset() {
	*x = EnsureSubscriptionRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureSubscriptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureSubscriptionRequest) ProtoMessage() {}

func (x *EnsureSubscriptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureSubscriptionRequest.ProtoReflect.Descriptor instead.
func (*EnsureSubscriptionRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{22}
}

func (x *EnsureSubscriptionRequest) GetSubscriptionId() int64 {
	if x != nil {
		return x.SubscriptionId
	}
	return 0
}

func (x *EnsureSubscriptionRequest) GetForceReconnect() bool {
	if x != nil {
		return x.ForceReconnect
	}
	return false
}

// An element received by a subscriber after calling receive.
type TopicElement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The channel that the element was received from.
	Channel int32 `protobuf:"varint,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The serialized binary value
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The position the element was in the topic
	Position *TopicPosition `protobuf:"bytes,3,opt,name=position,proto3" json:"position,omitempty"`
	// the timestamp the value was published
	Timestamp     *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopicElement) Reset() {
	*x = TopicElement{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopicElement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopicElement) ProtoMessage() {}

func (x *TopicElement) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopicElement.ProtoReflect.Descriptor instead.
func (*TopicElement) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{23}
}

func (x *TopicElement) GetChannel() int32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *TopicElement) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *TopicElement) GetPosition() *TopicPosition {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *TopicElement) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

type ReceiveRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The channel to received from.
	Channel int32 `protobuf:"varint,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The maximum number of messages to return.
	// If not set (or <= 0) multiple messages may be returned, in which case
	// the exact number will be determined by the topic implementation
	// on the server.
	MaxMessages   *int32 `protobuf:"varint,2,opt,name=maxMessages,proto3,oneof" json:"maxMessages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReceiveRequest) Reset() {
	*x = ReceiveRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReceiveRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReceiveRequest) ProtoMessage() {}

func (x *ReceiveRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReceiveRequest.ProtoReflect.Descriptor instead.
func (*ReceiveRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{24}
}

func (x *ReceiveRequest) GetChannel() int32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *ReceiveRequest) GetMaxMessages() int32 {
	if x != nil && x.MaxMessages != nil {
		return *x.MaxMessages
	}
	return 0
}

type ReceiveResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The status of the receive result.
	Status ReceiveStatus `protobuf:"varint,1,opt,name=status,proto3,enum=coherence.topic.v1.ReceiveStatus" json:"status,omitempty"`
	// The serialized values received from the channel.
	Values [][]byte `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// The new head position for the channel.
	HeadPosition *TopicPosition `protobuf:"bytes,3,opt,name=headPosition,proto3" json:"headPosition,omitempty"`
	// The count of the remaining values.
	RemainingValues int32 `protobuf:"varint,4,opt,name=remainingValues,proto3" json:"remainingValues,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *ReceiveResponse) Reset() {
	*x = ReceiveResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReceiveResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReceiveResponse) ProtoMessage() {}

func (x *ReceiveResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReceiveResponse.ProtoReflect.Descriptor instead.
func (*ReceiveResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{25}
}

func (x *ReceiveResponse) GetStatus() ReceiveStatus {
	if x != nil {
		return x.Status
	}
	return ReceiveStatus_ReceiveSuccess
}

func (x *ReceiveResponse) GetValues() [][]byte {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *ReceiveResponse) GetHeadPosition() *TopicPosition {
	if x != nil {
		return x.HeadPosition
	}
	return nil
}

func (x *ReceiveResponse) GetRemainingValues() int32 {
	if x != nil {
		return x.RemainingValues
	}
	return 0
}

// A request to seek (reposition) one or more channels.
type SeekRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The positions to seek to.
	//
	// Types that are valid to be assigned to Positions:
	//
	//	*SeekRequest_ByPosition
	//	*SeekRequest_ByTimestamp
	Positions     isSeekRequest_Positions `protobuf_oneof:"positions"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SeekRequest) Reset() {
	*x = SeekRequest{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SeekRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeekRequest) ProtoMessage() {}

func (x *SeekRequest) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeekRequest.ProtoReflect.Descriptor instead.
func (*SeekRequest) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{26}
}

func (x *SeekRequest) GetPositions() isSeekRequest_Positions {
	if x != nil {
		return x.Positions
	}
	return nil
}

func (x *SeekRequest) GetByPosition() *MapOfChannelAndPosition {
	if x != nil {
		if x, ok := x.Positions.(*SeekRequest_ByPosition); ok {
			return x.ByPosition
		}
	}
	return nil
}

func (x *SeekRequest) GetByTimestamp() *MapOfChannelAndTimestamp {
	if x != nil {
		if x, ok := x.Positions.(*SeekRequest_ByTimestamp); ok {
			return x.ByTimestamp
		}
	}
	return nil
}

type isSeekRequest_Positions interface {
	isSeekRequest_Positions()
}

type SeekRequest_ByPosition struct {
	// Seek to the specified positions in channels.
	ByPosition *MapOfChannelAndPosition `protobuf:"bytes,1,opt,name=byPosition,proto3,oneof"`
}

type SeekRequest_ByTimestamp struct {
	// Seek to the specified timestamps in channels.
	ByTimestamp *MapOfChannelAndTimestamp `protobuf:"bytes,2,opt,name=byTimestamp,proto3,oneof"`
}

func (*SeekRequest_ByPosition) isSeekRequest_Positions() {}

func (*SeekRequest_ByTimestamp) isSeekRequest_Positions() {}

// The result of a seek request for a channel.
type SeekedPositions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The new head position.
	Head *TopicPosition `protobuf:"bytes,2,opt,name=head,proto3" json:"head,omitempty"`
	// The seeked to position.
	SeekedTo      *TopicPosition `protobuf:"bytes,3,opt,name=seekedTo,proto3" json:"seekedTo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SeekedPositions) Reset() {
	*x = SeekedPositions{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SeekedPositions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeekedPositions) ProtoMessage() {}

func (x *SeekedPositions) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeekedPositions.ProtoReflect.Descriptor instead.
func (*SeekedPositions) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{27}
}

func (x *SeekedPositions) GetHead() *TopicPosition {
	if x != nil {
		return x.Head
	}
	return nil
}

func (x *SeekedPositions) GetSeekedTo() *TopicPosition {
	if x != nil {
		return x.SeekedTo
	}
	return nil
}

// The result of a seek request.
type SeekResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The map of SeekedPositions by channel.
	Positions     map[int32]*SeekedPositions `protobuf:"bytes,1,rep,name=positions,proto3" json:"positions,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SeekResponse) Reset() {
	*x = SeekResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SeekResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SeekResponse) ProtoMessage() {}

func (x *SeekResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SeekResponse.ProtoReflect.Descriptor instead.
func (*SeekResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{28}
}

func (x *SeekResponse) GetPositions() map[int32]*SeekedPositions {
	if x != nil {
		return x.Positions
	}
	return nil
}

// The result of a commit request
type CommitResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The channel committed.
	Channel int32 `protobuf:"varint,1,opt,name=channel,proto3" json:"channel,omitempty"`
	// The position committed.
	Position *TopicPosition `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	// The channel's head position.
	Head *TopicPosition `protobuf:"bytes,3,opt,name=head,proto3" json:"head,omitempty"`
	// The status of the commit response.
	Status CommitResponseStatus `protobuf:"varint,4,opt,name=status,proto3,enum=coherence.topic.v1.CommitResponseStatus" json:"status,omitempty"`
	// Any error that may hav occurred
	Error         *v1.ErrorMessage `protobuf:"bytes,5,opt,name=error,proto3,oneof" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitResponse) Reset() {
	*x = CommitResponse{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitResponse) ProtoMessage() {}

func (x *CommitResponse) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitResponse.ProtoReflect.Descriptor instead.
func (*CommitResponse) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{29}
}

func (x *CommitResponse) GetChannel() int32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *CommitResponse) GetPosition() *TopicPosition {
	if x != nil {
		return x.Position
	}
	return nil
}

func (x *CommitResponse) GetHead() *TopicPosition {
	if x != nil {
		return x.Head
	}
	return nil
}

func (x *CommitResponse) GetStatus() CommitResponseStatus {
	if x != nil {
		return x.Status
	}
	return CommitResponseStatus_Committed
}

func (x *CommitResponse) GetError() *v1.ErrorMessage {
	if x != nil {
		return x.Error
	}
	return nil
}

// A channel and position.
type ChannelAndPosition struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Channel       int32                  `protobuf:"varint,1,opt,name=channel,proto3" json:"channel,omitempty"`
	Position      *TopicPosition         `protobuf:"bytes,2,opt,name=position,proto3" json:"position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChannelAndPosition) Reset() {
	*x = ChannelAndPosition{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChannelAndPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChannelAndPosition) ProtoMessage() {}

func (x *ChannelAndPosition) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChannelAndPosition.ProtoReflect.Descriptor instead.
func (*ChannelAndPosition) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{30}
}

func (x *ChannelAndPosition) GetChannel() int32 {
	if x != nil {
		return x.Channel
	}
	return 0
}

func (x *ChannelAndPosition) GetPosition() *TopicPosition {
	if x != nil {
		return x.Position
	}
	return nil
}

// A map of topic channel identifier to position.
type MapOfChannelAndPosition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The map of channels to positions.
	Positions     map[int32]*TopicPosition `protobuf:"bytes,1,rep,name=positions,proto3" json:"positions,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapOfChannelAndPosition) Reset() {
	*x = MapOfChannelAndPosition{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapOfChannelAndPosition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapOfChannelAndPosition) ProtoMessage() {}

func (x *MapOfChannelAndPosition) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapOfChannelAndPosition.ProtoReflect.Descriptor instead.
func (*MapOfChannelAndPosition) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{31}
}

func (x *MapOfChannelAndPosition) GetPositions() map[int32]*TopicPosition {
	if x != nil {
		return x.Positions
	}
	return nil
}

// A map of topic channel identifier to timestamps.
type MapOfChannelAndTimestamp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The map of channels to timestamps.
	Timestamps    map[int32]*timestamppb.Timestamp `protobuf:"bytes,1,rep,name=timestamps,proto3" json:"timestamps,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapOfChannelAndTimestamp) Reset() {
	*x = MapOfChannelAndTimestamp{}
	mi := &file_topic_service_messages_v1_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapOfChannelAndTimestamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapOfChannelAndTimestamp) ProtoMessage() {}

func (x *MapOfChannelAndTimestamp) ProtoReflect() protoreflect.Message {
	mi := &file_topic_service_messages_v1_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapOfChannelAndTimestamp.ProtoReflect.Descriptor instead.
func (*MapOfChannelAndTimestamp) Descriptor() ([]byte, []int) {
	return file_topic_service_messages_v1_proto_rawDescGZIP(), []int{32}
}

func (x *MapOfChannelAndTimestamp) GetTimestamps() map[int32]*timestamppb.Timestamp {
	if x != nil {
		return x.Timestamps
	}
	return nil
}

var File_topic_service_messages_v1_proto protoreflect.FileDescriptor

const file_topic_service_messages_v1_proto_rawDesc = "" +
	"\n" +
	"\x1ftopic_service_messages_v1.proto\x12\x12coherence.topic.v1\x1a\x18common_messages_v1.proto\x1a\x19google/protobuf/any.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xc2\x01\n" +
	"\x13TopicServiceRequest\x12?\n" +
	"\x04type\x18\x01 \x01(\x0e2+.coherence.topic.v1.TopicServiceRequestTypeR\x04type\x12\x1d\n" +
	"\aproxyId\x18\x02 \x01(\x05H\x00R\aproxyId\x88\x01\x01\x123\n" +
	"\amessage\x18\x03 \x01(\v2\x14.google.protobuf.AnyH\x01R\amessage\x88\x01\x01B\n" +
	"\n" +
	"\b_proxyIdB\n" +
	"\n" +
	"\b_message\"\xa7\x01\n" +
	"\x14TopicServiceResponse\x12\x18\n" +
	"\aproxyId\x18\x01 \x01(\x05R\aproxyId\x124\n" +
	"\x04type\x18\x02 \x01(\x0e2 .coherence.topic.v1.ResponseTypeR\x04type\x123\n" +
	"\amessage\x18\x03 \x01(\v2\x14.google.protobuf.AnyH\x00R\amessage\x88\x01\x01B\n" +
	"\n" +
	"\b_message\"*\n" +
	"\x12EnsureTopicRequest\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\"I\n" +
	"\x0fNamedTopicEvent\x126\n" +
	"\x04type\x18\x01 \x01(\x0e2\".coherence.topic.v1.TopicEventTypeR\x04type\"\xa0\x01\n" +
	"\x19EnsureChannelCountRequest\x12\x19\n" +
	"\x05topic\x18\x01 \x01(\tH\x00R\x05topic\x88\x01\x01\x12$\n" +
	"\rrequiredCount\x18\x02 \x01(\x05R\rrequiredCount\x12'\n" +
	"\fchannelCount\x18\x03 \x01(\x05H\x01R\fchannelCount\x88\x01\x01B\b\n" +
	"\x06_topicB\x0f\n" +
	"\r_channelCount\"\xa1\x01\n" +
	"\x1cEnsureSubscriberGroupRequest\x12(\n" +
	"\x0fsubscriberGroup\x18\x02 \x01(\tR\x0fsubscriberGroup\x12\x1b\n" +
	"\x06filter\x18\x03 \x01(\fH\x00R\x06filter\x88\x01\x01\x12!\n" +
	"\textractor\x18\x04 \x01(\fH\x01R\textractor\x88\x01\x01B\t\n" +
	"\a_filterB\f\n" +
	"\n" +
	"_extractor\"\x88\x01\n" +
	"\x1bGetRemainingMessagesRequest\x12\x19\n" +
	"\x05topic\x18\x01 \x01(\tH\x00R\x05topic\x88\x01\x01\x12(\n" +
	"\x0fsubscriberGroup\x18\x02 \x01(\tR\x0fsubscriberGroup\x12\x1a\n" +
	"\bchannels\x18\x03 \x03(\x05R\bchannelsB\b\n" +
	"\x06_topic\"R\n" +
	"\x16EnsurePublisherRequest\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12\"\n" +
	"\fchannelCount\x18\x02 \x01(\x05R\fchannelCount\"\x9d\x01\n" +
	"\x17EnsurePublisherResponse\x12\x18\n" +
	"\aproxyId\x18\x01 \x01(\x05R\aproxyId\x12 \n" +
	"\vpublisherId\x18\x02 \x01(\x03R\vpublisherId\x12\"\n" +
	"\fchannelCount\x18\x03 \x01(\x05R\fchannelCount\x12\"\n" +
	"\fmaxBatchSize\x18\x04 \x01(\x03R\fmaxBatchSize\"l\n" +
	"\x0ePublisherEvent\x12:\n" +
	"\x04type\x18\x01 \x01(\x0e2&.coherence.topic.v1.PublisherEventTypeR\x04type\x12\x1e\n" +
	"\bchannels\x18\x02 \x03(\x05B\x02\x10\x01R\bchannels\"\x9a\x01\n" +
	"\x0ePublishRequest\x12\x18\n" +
	"\achannel\x18\x02 \x01(\x05R\achannel\x12\x16\n" +
	"\x06values\x18\x03 \x03(\fR\x06values\x12;\n" +
	"\x16notificationIdentifier\x18\x04 \x01(\x05H\x00R\x16notificationIdentifier\x88\x01\x01B\x19\n" +
	"\x17_notificationIdentifier\"\x9b\x01\n" +
	"\x14PublishedValueStatus\x12?\n" +
	"\bposition\x18\x01 \x01(\v2!.coherence.topic.v1.TopicPositionH\x00R\bposition\x129\n" +
	"\x05error\x18\x02 \x01(\v2!.coherence.common.v1.ErrorMessageH\x00R\x05errorB\a\n" +
	"\x05state\"\x84\x02\n" +
	"\rPublishResult\x12\x18\n" +
	"\achannel\x18\x01 \x01(\x05R\achannel\x129\n" +
	"\x06status\x18\x03 \x01(\x0e2!.coherence.topic.v1.PublishStatusR\x06status\x12$\n" +
	"\racceptedCount\x18\x05 \x01(\x05R\racceptedCount\x12,\n" +
	"\x11remainingCapacity\x18\x06 \x01(\x05R\x11remainingCapacity\x12J\n" +
	"\vvalueStatus\x18\a \x03(\v2(.coherence.topic.v1.PublishedValueStatusR\vvalueStatus\";\n" +
	"\rPagedPosition\x12\x12\n" +
	"\x04page\x18\x01 \x01(\x03R\x04page\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x05R\x06offset\"A\n" +
	"\rTopicPosition\x120\n" +
	"\bposition\x18\x01 \x01(\v2\x14.google.protobuf.AnyR\bposition\"\xbb\x01\n" +
	"\x18EnsureSubscriberResponse\x12\x18\n" +
	"\aproxyId\x18\x01 \x01(\x05R\aproxyId\x12D\n" +
	"\fsubscriberId\x18\x02 \x01(\v2 .coherence.topic.v1.SubscriberIdR\fsubscriberId\x12?\n" +
	"\agroupId\x18\x03 \x01(\v2%.coherence.topic.v1.SubscriberGroupIdR\agroupId\"\x91\x02\n" +
	"\x17EnsureSubscriberRequest\x12\x14\n" +
	"\x05topic\x18\x01 \x01(\tR\x05topic\x12-\n" +
	"\x0fsubscriberGroup\x18\x02 \x01(\tH\x00R\x0fsubscriberGroup\x88\x01\x01\x12\x1b\n" +
	"\x06filter\x18\x03 \x01(\fH\x01R\x06filter\x88\x01\x01\x12!\n" +
	"\textractor\x18\x04 \x01(\fH\x02R\textractor\x88\x01\x01\x12(\n" +
	"\x0fcompleteOnEmpty\x18\x05 \x01(\bR\x0fcompleteOnEmpty\x12\x1a\n" +
	"\bchannels\x18\x06 \x03(\x05R\bchannelsB\x12\n" +
	"\x10_subscriberGroupB\t\n" +
	"\a_filterB\f\n" +
	"\n" +
	"_extractor\"n\n" +
	"\x0fSubscriberEvent\x12;\n" +
	"\x04type\x18\x01 \x01(\x0e2'.coherence.topic.v1.SubscriberEventTypeR\x04type\x12\x1e\n" +
	"\bchannels\x18\x02 \x03(\x05B\x02\x10\x01R\bchannels\"2\n" +
	"\fSubscriberId\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x03R\x02id\x12\x12\n" +
	"\x04uuid\x18\x04 \x01(\fR\x04uuid\"7\n" +
	"\x11SubscriberGroupId\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x0e\n" +
	"\x02id\x18\x02 \x01(\x03R\x02id\"\x89\x01\n" +
	"\x1dInitializeSubscriptionRequest\x12\"\n" +
	"\fdisconnected\x18\x01 \x01(\bR\fdisconnected\x12\x1c\n" +
	"\treconnect\x18\x02 \x01(\bR\treconnect\x12&\n" +
	"\x0eforceReconnect\x18\x03 \x01(\bR\x0eforceReconnect\"\xbb\x01\n" +
	"\x1eInitializeSubscriptionResponse\x12&\n" +
	"\x0esubscriptionId\x18\x01 \x01(\x03R\x0esubscriptionId\x128\n" +
	"\ttimestamp\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x127\n" +
	"\x05heads\x18\x03 \x03(\v2!.coherence.topic.v1.TopicPositionR\x05heads\"k\n" +
	"\x19EnsureSubscriptionRequest\x12&\n" +
	"\x0esubscriptionId\x18\x01 \x01(\x03R\x0esubscriptionId\x12&\n" +
	"\x0eforceReconnect\x18\x02 \x01(\bR\x0eforceReconnect\"\xb7\x01\n" +
	"\fTopicElement\x12\x18\n" +
	"\achannel\x18\x01 \x01(\x05R\achannel\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x12=\n" +
	"\bposition\x18\x03 \x01(\v2!.coherence.topic.v1.TopicPositionR\bposition\x128\n" +
	"\ttimestamp\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\"a\n" +
	"\x0eReceiveRequest\x12\x18\n" +
	"\achannel\x18\x01 \x01(\x05R\achannel\x12%\n" +
	"\vmaxMessages\x18\x02 \x01(\x05H\x00R\vmaxMessages\x88\x01\x01B\x0e\n" +
	"\f_maxMessages\"\xd5\x01\n" +
	"\x0fReceiveResponse\x129\n" +
	"\x06status\x18\x01 \x01(\x0e2!.coherence.topic.v1.ReceiveStatusR\x06status\x12\x16\n" +
	"\x06values\x18\x02 \x03(\fR\x06values\x12E\n" +
	"\fheadPosition\x18\x03 \x01(\v2!.coherence.topic.v1.TopicPositionR\fheadPosition\x12(\n" +
	"\x0fremainingValues\x18\x04 \x01(\x05R\x0fremainingValues\"\xbb\x01\n" +
	"\vSeekRequest\x12M\n" +
	"\n" +
	"byPosition\x18\x01 \x01(\v2+.coherence.topic.v1.MapOfChannelAndPositionH\x00R\n" +
	"byPosition\x12P\n" +
	"\vbyTimestamp\x18\x02 \x01(\v2,.coherence.topic.v1.MapOfChannelAndTimestampH\x00R\vbyTimestampB\v\n" +
	"\tpositions\"\x87\x01\n" +
	"\x0fSeekedPositions\x125\n" +
	"\x04head\x18\x02 \x01(\v2!.coherence.topic.v1.TopicPositionR\x04head\x12=\n" +
	"\bseekedTo\x18\x03 \x01(\v2!.coherence.topic.v1.TopicPositionR\bseekedTo\"\xc0\x01\n" +
	"\fSeekResponse\x12M\n" +
	"\tpositions\x18\x01 \x03(\v2/.coherence.topic.v1.SeekResponse.PositionsEntryR\tpositions\x1aa\n" +
	"\x0ePositionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x129\n" +
	"\x05value\x18\x02 \x01(\v2#.coherence.topic.v1.SeekedPositionsR\x05value:\x028\x01\"\xaa\x02\n" +
	"\x0eCommitResponse\x12\x18\n" +
	"\achannel\x18\x01 \x01(\x05R\achannel\x12=\n" +
	"\bposition\x18\x02 \x01(\v2!.coherence.topic.v1.TopicPositionR\bposition\x125\n" +
	"\x04head\x18\x03 \x01(\v2!.coherence.topic.v1.TopicPositionR\x04head\x12@\n" +
	"\x06status\x18\x04 \x01(\x0e2(.coherence.topic.v1.CommitResponseStatusR\x06status\x12<\n" +
	"\x05error\x18\x05 \x01(\v2!.coherence.common.v1.ErrorMessageH\x00R\x05error\x88\x01\x01B\b\n" +
	"\x06_error\"m\n" +
	"\x12ChannelAndPosition\x12\x18\n" +
	"\achannel\x18\x01 \x01(\x05R\achannel\x12=\n" +
	"\bposition\x18\x02 \x01(\v2!.coherence.topic.v1.TopicPositionR\bposition\"\xd4\x01\n" +
	"\x17MapOfChannelAndPosition\x12X\n" +
	"\tpositions\x18\x01 \x03(\v2:.coherence.topic.v1.MapOfChannelAndPosition.PositionsEntryR\tpositions\x1a_\n" +
	"\x0ePositionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x127\n" +
	"\x05value\x18\x02 \x01(\v2!.coherence.topic.v1.TopicPositionR\x05value:\x028\x01\"\xd3\x01\n" +
	"\x18MapOfChannelAndTimestamp\x12\\\n" +
	"\n" +
	"timestamps\x18\x01 \x03(\v2<.coherence.topic.v1.MapOfChannelAndTimestamp.TimestampsEntryR\n" +
	"timestamps\x1aY\n" +
	"\x0fTimestampsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\x05R\x03key\x120\n" +
	"\x05value\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x05value:\x028\x01*\xcc\x04\n" +
	"\x17TopicServiceRequestType\x12\x12\n" +
	"\x0eRequestUnknown\x10\x00\x12\x0f\n" +
	"\vEnsureTopic\x10\x01\x12\x10\n" +
	"\fDestroyTopic\x10\x02\x12\x13\n" +
	"\x0fGetChannelCount\x10\x03\x12\x17\n" +
	"\x13GetSubscriberGroups\x10\x04\x12\x16\n" +
	"\x12EnsureChannelCount\x10\x05\x12\x19\n" +
	"\x15EnsureSubscriberGroup\x10\x06\x12\x1a\n" +
	"\x16DestroySubscriberGroup\x10\a\x12\x18\n" +
	"\x14GetRemainingMessages\x10\b\x12\f\n" +
	"\bGetTails\x10\t\x12\x13\n" +
	"\x0fEnsurePublisher\x10\n" +
	"\x12\x14\n" +
	"\x10DestroyPublisher\x10\v\x12\v\n" +
	"\aPublish\x10\f\x12\x14\n" +
	"\x10EnsureSubscriber\x10\r\x12\x15\n" +
	"\x11DestroySubscriber\x10\x0e\x12\x1a\n" +
	"\x16InitializeSubscription\x10\x0f\x12\x16\n" +
	"\x12EnsureSubscription\x10\x10\x12\x16\n" +
	"\x12GetSubscriberHeads\x10\x11\x12\x13\n" +
	"\x0fGetLastCommited\x10\x12\x12\x14\n" +
	"\x10GetOwnedChannels\x10\x13\x12\x17\n" +
	"\x13SubscriberHeartbeat\x10\x14\x12\x17\n" +
	"\x13IsPositionCommitted\x10\x15\x12\x12\n" +
	"\x0ePeekAtPosition\x10\x16\x12\v\n" +
	"\aReceive\x10\x17\x12\x12\n" +
	"\x0eSeekSubscriber\x10\x18\x12\x12\n" +
	"\x0eCommitPosition\x10\x19*&\n" +
	"\fResponseType\x12\v\n" +
	"\aMessage\x10\x00\x12\t\n" +
	"\x05Event\x10\x01*6\n" +
	"\x0eTopicEventType\x12\x10\n" +
	"\fEventUnknown\x10\x00\x12\x12\n" +
	"\x0eTopicDestroyed\x10\x01*\xad\x01\n" +
	"\x12PublisherEventType\x12\x19\n" +
	"\x15PublisherEventUnknown\x10\x00\x12\x16\n" +
	"\x12PublisherConnected\x10\x01\x12\x19\n" +
	"\x15PublisherDisconnected\x10\x02\x12\x1a\n" +
	"\x16PublisherChannelsFreed\x10\x03\x12\x16\n" +
	"\x12PublisherDestroyed\x10\x04\x12\x15\n" +
	"\x11PublisherReleased\x10\x05*+\n" +
	"\rPublishStatus\x12\v\n" +
	"\aSuccess\x10\x00\x12\r\n" +
	"\tTopicFull\x10\x01*\xb0\x02\n" +
	"\x13SubscriberEventType\x12\x1a\n" +
	"\x16SubscriberEventUnknown\x10\x00\x12\x1c\n" +
	"\x18SubscriberGroupDestroyed\x10\x01\x12\x1f\n" +
	"\x1bSubscriberChannelAllocation\x10\x02\x12\x1a\n" +
	"\x16SubscriberChannelsLost\x10\x03\x12\x1e\n" +
	"\x1aSubscriberChannelPopulated\x10\x04\x12\x19\n" +
	"\x15SubscriberChannelHead\x10\x05\x12\x1a\n" +
	"\x16SubscriberUnsubscribed\x10\x06\x12\x17\n" +
	"\x13SubscriberDestroyed\x10\a\x12\x16\n" +
	"\x12SubscriberReleased\x10\b\x12\x1a\n" +
	"\x16SubscriberDisconnected\x10\t*p\n" +
	"\rReceiveStatus\x12\x12\n" +
	"\x0eReceiveSuccess\x10\x00\x12\x14\n" +
	"\x10ChannelExhausted\x10\x01\x12\x1e\n" +
	"\x1aChannelNotAllocatedChannel\x10\x02\x12\x15\n" +
	"\x11UnknownSubscriber\x10\x03*k\n" +
	"\x14CommitResponseStatus\x12\r\n" +
	"\tCommitted\x10\x00\x12\x14\n" +
	"\x10AlreadyCommitted\x10\x01\x12\f\n" +
	"\bRejected\x10\x02\x12\v\n" +
	"\aUnowned\x10\x03\x12\x13\n" +
	"\x0fNothingToCommit\x10\x04Bf\n" +
	"+com.oracle.coherence.grpc.messages.topic.v1P\x01Z5github.com/oracle/coherence-go-client/proto/v1/topicsb\x06proto3"

var (
	file_topic_service_messages_v1_proto_rawDescOnce sync.Once
	file_topic_service_messages_v1_proto_rawDescData []byte
)

func file_topic_service_messages_v1_proto_rawDescGZIP() []byte {
	file_topic_service_messages_v1_proto_rawDescOnce.Do(func() {
		file_topic_service_messages_v1_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_topic_service_messages_v1_proto_rawDesc), len(file_topic_service_messages_v1_proto_rawDesc)))
	})
	return file_topic_service_messages_v1_proto_rawDescData
}

var file_topic_service_messages_v1_proto_enumTypes = make([]protoimpl.EnumInfo, 8)
var file_topic_service_messages_v1_proto_msgTypes = make([]protoimpl.MessageInfo, 36)
var file_topic_service_messages_v1_proto_goTypes = []any{
	(TopicServiceRequestType)(0),           // 0: coherence.topic.v1.TopicServiceRequestType
	(ResponseType)(0),                      // 1: coherence.topic.v1.ResponseType
	(TopicEventType)(0),                    // 2: coherence.topic.v1.TopicEventType
	(PublisherEventType)(0),                // 3: coherence.topic.v1.PublisherEventType
	(PublishStatus)(0),                     // 4: coherence.topic.v1.PublishStatus
	(SubscriberEventType)(0),               // 5: coherence.topic.v1.SubscriberEventType
	(ReceiveStatus)(0),                     // 6: coherence.topic.v1.ReceiveStatus
	(CommitResponseStatus)(0),              // 7: coherence.topic.v1.CommitResponseStatus
	(*TopicServiceRequest)(nil),            // 8: coherence.topic.v1.TopicServiceRequest
	(*TopicServiceResponse)(nil),           // 9: coherence.topic.v1.TopicServiceResponse
	(*EnsureTopicRequest)(nil),             // 10: coherence.topic.v1.EnsureTopicRequest
	(*NamedTopicEvent)(nil),                // 11: coherence.topic.v1.NamedTopicEvent
	(*EnsureChannelCountRequest)(nil),      // 12: coherence.topic.v1.EnsureChannelCountRequest
	(*EnsureSubscriberGroupRequest)(nil),   // 13: coherence.topic.v1.EnsureSubscriberGroupRequest
	(*GetRemainingMessagesRequest)(nil),    // 14: coherence.topic.v1.GetRemainingMessagesRequest
	(*EnsurePublisherRequest)(nil),         // 15: coherence.topic.v1.EnsurePublisherRequest
	(*EnsurePublisherResponse)(nil),        // 16: coherence.topic.v1.EnsurePublisherResponse
	(*PublisherEvent)(nil),                 // 17: coherence.topic.v1.PublisherEvent
	(*PublishRequest)(nil),                 // 18: coherence.topic.v1.PublishRequest
	(*PublishedValueStatus)(nil),           // 19: coherence.topic.v1.PublishedValueStatus
	(*PublishResult)(nil),                  // 20: coherence.topic.v1.PublishResult
	(*PagedPosition)(nil),                  // 21: coherence.topic.v1.PagedPosition
	(*TopicPosition)(nil),                  // 22: coherence.topic.v1.TopicPosition
	(*EnsureSubscriberResponse)(nil),       // 23: coherence.topic.v1.EnsureSubscriberResponse
	(*EnsureSubscriberRequest)(nil),        // 24: coherence.topic.v1.EnsureSubscriberRequest
	(*SubscriberEvent)(nil),                // 25: coherence.topic.v1.SubscriberEvent
	(*SubscriberId)(nil),                   // 26: coherence.topic.v1.SubscriberId
	(*SubscriberGroupId)(nil),              // 27: coherence.topic.v1.SubscriberGroupId
	(*InitializeSubscriptionRequest)(nil),  // 28: coherence.topic.v1.InitializeSubscriptionRequest
	(*InitializeSubscriptionResponse)(nil), // 29: coherence.topic.v1.InitializeSubscriptionResponse
	(*EnsureSubscriptionRequest)(nil),      // 30: coherence.topic.v1.EnsureSubscriptionRequest
	(*TopicElement)(nil),                   // 31: coherence.topic.v1.TopicElement
	(*ReceiveRequest)(nil),                 // 32: coherence.topic.v1.ReceiveRequest
	(*ReceiveResponse)(nil),                // 33: coherence.topic.v1.ReceiveResponse
	(*SeekRequest)(nil),                    // 34: coherence.topic.v1.SeekRequest
	(*SeekedPositions)(nil),                // 35: coherence.topic.v1.SeekedPositions
	(*SeekResponse)(nil),                   // 36: coherence.topic.v1.SeekResponse
	(*CommitResponse)(nil),                 // 37: coherence.topic.v1.CommitResponse
	(*ChannelAndPosition)(nil),             // 38: coherence.topic.v1.ChannelAndPosition
	(*MapOfChannelAndPosition)(nil),        // 39: coherence.topic.v1.MapOfChannelAndPosition
	(*MapOfChannelAndTimestamp)(nil),       // 40: coherence.topic.v1.MapOfChannelAndTimestamp
	nil,                                    // 41: coherence.topic.v1.SeekResponse.PositionsEntry
	nil,                                    // 42: coherence.topic.v1.MapOfChannelAndPosition.PositionsEntry
	nil,                                    // 43: coherence.topic.v1.MapOfChannelAndTimestamp.TimestampsEntry
	(*anypb.Any)(nil),                      // 44: google.protobuf.Any
	(*v1.ErrorMessage)(nil),                // 45: coherence.common.v1.ErrorMessage
	(*timestamppb.Timestamp)(nil),          // 46: google.protobuf.Timestamp
}
var file_topic_service_messages_v1_proto_depIdxs = []int32{
	0,  // 0: coherence.topic.v1.TopicServiceRequest.type:type_name -> coherence.topic.v1.TopicServiceRequestType
	44, // 1: coherence.topic.v1.TopicServiceRequest.message:type_name -> google.protobuf.Any
	1,  // 2: coherence.topic.v1.TopicServiceResponse.type:type_name -> coherence.topic.v1.ResponseType
	44, // 3: coherence.topic.v1.TopicServiceResponse.message:type_name -> google.protobuf.Any
	2,  // 4: coherence.topic.v1.NamedTopicEvent.type:type_name -> coherence.topic.v1.TopicEventType
	3,  // 5: coherence.topic.v1.PublisherEvent.type:type_name -> coherence.topic.v1.PublisherEventType
	22, // 6: coherence.topic.v1.PublishedValueStatus.position:type_name -> coherence.topic.v1.TopicPosition
	45, // 7: coherence.topic.v1.PublishedValueStatus.error:type_name -> coherence.common.v1.ErrorMessage
	4,  // 8: coherence.topic.v1.PublishResult.status:type_name -> coherence.topic.v1.PublishStatus
	19, // 9: coherence.topic.v1.PublishResult.valueStatus:type_name -> coherence.topic.v1.PublishedValueStatus
	44, // 10: coherence.topic.v1.TopicPosition.position:type_name -> google.protobuf.Any
	26, // 11: coherence.topic.v1.EnsureSubscriberResponse.subscriberId:type_name -> coherence.topic.v1.SubscriberId
	27, // 12: coherence.topic.v1.EnsureSubscriberResponse.groupId:type_name -> coherence.topic.v1.SubscriberGroupId
	5,  // 13: coherence.topic.v1.SubscriberEvent.type:type_name -> coherence.topic.v1.SubscriberEventType
	46, // 14: coherence.topic.v1.InitializeSubscriptionResponse.timestamp:type_name -> google.protobuf.Timestamp
	22, // 15: coherence.topic.v1.InitializeSubscriptionResponse.heads:type_name -> coherence.topic.v1.TopicPosition
	22, // 16: coherence.topic.v1.TopicElement.position:type_name -> coherence.topic.v1.TopicPosition
	46, // 17: coherence.topic.v1.TopicElement.timestamp:type_name -> google.protobuf.Timestamp
	6,  // 18: coherence.topic.v1.ReceiveResponse.status:type_name -> coherence.topic.v1.ReceiveStatus
	22, // 19: coherence.topic.v1.ReceiveResponse.headPosition:type_name -> coherence.topic.v1.TopicPosition
	39, // 20: coherence.topic.v1.SeekRequest.byPosition:type_name -> coherence.topic.v1.MapOfChannelAndPosition
	40, // 21: coherence.topic.v1.SeekRequest.byTimestamp:type_name -> coherence.topic.v1.MapOfChannelAndTimestamp
	22, // 22: coherence.topic.v1.SeekedPositions.head:type_name -> coherence.topic.v1.TopicPosition
	22, // 23: coherence.topic.v1.SeekedPositions.seekedTo:type_name -> coherence.topic.v1.TopicPosition
	41, // 24: coherence.topic.v1.SeekResponse.positions:type_name -> coherence.topic.v1.SeekResponse.PositionsEntry
	22, // 25: coherence.topic.v1.CommitResponse.position:type_name -> coherence.topic.v1.TopicPosition
	22, // 26: coherence.topic.v1.CommitResponse.head:type_name -> coherence.topic.v1.TopicPosition
	7,  // 27: coherence.topic.v1.CommitResponse.status:type_name -> coherence.topic.v1.CommitResponseStatus
	45, // 28: coherence.topic.v1.CommitResponse.error:type_name -> coherence.common.v1.ErrorMessage
	22, // 29: coherence.topic.v1.ChannelAndPosition.position:type_name -> coherence.topic.v1.TopicPosition
	42, // 30: coherence.topic.v1.MapOfChannelAndPosition.positions:type_name -> coherence.topic.v1.MapOfChannelAndPosition.PositionsEntry
	43, // 31: coherence.topic.v1.MapOfChannelAndTimestamp.timestamps:type_name -> coherence.topic.v1.MapOfChannelAndTimestamp.TimestampsEntry
	35, // 32: coherence.topic.v1.SeekResponse.PositionsEntry.value:type_name -> coherence.topic.v1.SeekedPositions
	22, // 33: coherence.topic.v1.MapOfChannelAndPosition.PositionsEntry.value:type_name -> coherence.topic.v1.TopicPosition
	46, // 34: coherence.topic.v1.MapOfChannelAndTimestamp.TimestampsEntry.value:type_name -> google.protobuf.Timestamp
	35, // [35:35] is the sub-list for method output_type
	35, // [35:35] is the sub-list for method input_type
	35, // [35:35] is the sub-list for extension type_name
	35, // [35:35] is the sub-list for extension extendee
	0,  // [0:35] is the sub-list for field type_name
}

func init() { file_topic_service_messages_v1_proto_init() }
func file_topic_service_messages_v1_proto_init() {
	if File_topic_service_messages_v1_proto != nil {
		return
	}
	file_topic_service_messages_v1_proto_msgTypes[0].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[1].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[4].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[5].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[6].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[10].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[11].OneofWrappers = []any{
		(*PublishedValueStatus_Position)(nil),
		(*PublishedValueStatus_Error)(nil),
	}
	file_topic_service_messages_v1_proto_msgTypes[16].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[24].OneofWrappers = []any{}
	file_topic_service_messages_v1_proto_msgTypes[26].OneofWrappers = []any{
		(*SeekRequest_ByPosition)(nil),
		(*SeekRequest_ByTimestamp)(nil),
	}
	file_topic_service_messages_v1_proto_msgTypes[29].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_topic_service_messages_v1_proto_rawDesc), len(file_topic_service_messages_v1_proto_rawDesc)),
			NumEnums:      8,
			NumMessages:   36,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_topic_service_messages_v1_proto_goTypes,
		DependencyIndexes: file_topic_service_messages_v1_proto_depIdxs,
		EnumInfos:         file_topic_service_messages_v1_proto_enumTypes,
		MessageInfos:      file_topic_service_messages_v1_proto_msgTypes,
	}.Build()
	File_topic_service_messages_v1_proto = out.File
	file_topic_service_messages_v1_proto_goTypes = nil
	file_topic_service_messages_v1_proto_depIdxs = nil
}
