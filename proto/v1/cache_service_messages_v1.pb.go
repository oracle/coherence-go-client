//
// Copyright (c) 2020, 2024, Oracle and/or its affiliates.
//
// Licensed under the Universal Permissive License v 1.0 as shown at
// https://oss.oracle.com/licenses/upl.

// -----------------------------------------------------------------
// Messages used by the Coherence gRPC NamedCache Service.
//
// NOTE: If you add a new request message to this message the current
// protocol version in com.oracle.coherence.grpc.NamedCacheProtocol must
// be increased. This only needs to be done once for any given Coherence
// release.
// -----------------------------------------------------------------

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.19.2
// source: cache_service_messages_v1.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	anypb "google.golang.org/protobuf/types/known/anypb"
	_ "google.golang.org/protobuf/types/known/emptypb"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	_ "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// An enum representing the types of request for a Named Cache Service proxy
//
// NOTE: The index numbers for the enum elements MUST NOT BE CHANGED as
// that would break backwards compatibility. Only new index numbers can
// be added.
type NamedCacheRequestType int32

const (
	// An unknown message.
	// This request type is not used, it is here as enums must have a zero value,
	// but we need to know the difference between a zero value and the field being
	// incorrectly set.
	NamedCacheRequestType_Unknown NamedCacheRequestType = 0
	// Called to ensure a cache.
	// Must be the first message called prior to any other cache requests.
	// The message field must be an EnsureCacheRequest.
	// The response will contain the Cache Id and an empty response field.
	NamedCacheRequestType_EnsureCache NamedCacheRequestType = 1
	// Execute an aggregator on the cache and return the result.
	// The message field must contain an ExecuteRequest where the agent field
	// is the serialized aggregator.
	// The response will be a BytesValue containing the aggregator result.
	NamedCacheRequestType_Aggregate NamedCacheRequestType = 2
	// Clear the specified cache.
	// The message field should not be set.
	// The response will just be a Complete message corresponding to the request id.
	NamedCacheRequestType_Clear NamedCacheRequestType = 3
	// Determine whether the specified cache is contains a specified key mapped
	// to a specified value.
	// The message field must contain a BinaryKeyAndValue that contains the
	// serialized key and value.
	// The response will contain the Cache Id and a BoolValue in the response field.
	NamedCacheRequestType_ContainsEntry NamedCacheRequestType = 4
	// Determine whether the specified cache is contains a specified key.
	// The message field must contain a BytesValue that contains the
	// serialized key.
	// The response will contain the Cache Id and a BoolValue in the response field.
	NamedCacheRequestType_ContainsKey NamedCacheRequestType = 5
	// Determine whether the specified cache is contains a specified value.
	// The message field must contain a BytesValue that contains the
	// serialized value.
	// The response will contain the Cache Id and a BoolValue in the response field.
	NamedCacheRequestType_ContainsValue NamedCacheRequestType = 6
	// Destroy the specified cache.
	// The message field should not be set.
	// The response will just be a Complete message corresponding to the request id.
	NamedCacheRequestType_Destroy NamedCacheRequestType = 7
	// Determine whether the specified cache is empty.
	// The message field should not be set.
	// The response will contain the Cache Id and a BoolValue in the response field.
	NamedCacheRequestType_IsEmpty NamedCacheRequestType = 8
	// Determine whether the specified cache is ready.
	// The message field should not be set.
	// The response will contain the Cache Id and a BoolValue in the response field.
	NamedCacheRequestType_IsReady NamedCacheRequestType = 9
	// Determine whether the specified cache is contains a specified key.
	// The message field must contain a BytesValue that contains the
	// serialized key of the entry to get.
	// The response will contain the Cache Id and an OptionalValue that will be empty
	// if the cache did not contain an entry for the key or will contain the value from
	// the cache.
	NamedCacheRequestType_Get NamedCacheRequestType = 10
	// Return the values from the specified cache that are mapped to a collection of keys.
	// The message field must contain a CollectionOfBytesValues that contains the
	// serialized keys of the entries to get.
	// There will be multiple responses containing the Cache Id and an BinaryKeyAndValue for
	// each requested key.
	NamedCacheRequestType_GetAll NamedCacheRequestType = 11
	// Add or remove an index.
	// The message field must contain an IndexRequest.
	// The response will just be a Complete message corresponding to the request id.
	NamedCacheRequestType_Index NamedCacheRequestType = 12
	// Execute an entry processor against a single entry in the cache and return the result.
	// The message field must contain a ExecuteRequest where the agent field
	// is the serialized entry processor.
	// The response will be a stream of BinaryKeyAndValue values followed by a Complete
	// message to signal the end of the response stream.
	NamedCacheRequestType_Invoke NamedCacheRequestType = 13
	// Add or remove a MapListener.
	// The message field must contain a MapListenerRequest.
	// The response will just be a Complete message corresponding to the request id.
	NamedCacheRequestType_MapListener NamedCacheRequestType = 14
	// Retrieve a page of entries from the cache
	// The message field must contain a BytesValue that is the opaque cookie returned
	// by a previous page request, or an empty (or not set) BytesValue to retrieve the
	// first page.
	// The response will be a stream of results. The first response will be a BytesValue
	// which is the new cookie, followed by a stream of BinaryKeyAndValue messages for
	// each cache entry in the page, finally followed by a Complete message to signal
	// the end of the response stream.
	NamedCacheRequestType_PageOfEntries NamedCacheRequestType = 15
	// Retrieve a page of keys from the cache
	// The message field must contain a BytesValue that is the opaque cookie returned
	// by a previous page request, or an empty (or not set) BytesValue to retrieve the
	// first page.
	// The response will be a stream of results. The first response will be a BytesValue
	// which is the new cookie, followed by a stream of BytesValue messages for
	// each cache key in the page, finally followed by a Complete message to signal
	// the end of the response stream.
	NamedCacheRequestType_PageOfKeys NamedCacheRequestType = 16
	// Add a key and value to the cache, with an optional TTL.
	// The message field must contain a PutRequest that contains the
	// serialized key, serialized value and optional TTL.
	// The response will contain the Cache Id and an BytesValue that will be empty
	// if the cache did not contain an entry for the key or will contain the previous
	// value from the cache that was mapped to the key.
	NamedCacheRequestType_Put NamedCacheRequestType = 17
	// Add a set of keys and values to the cache, with an optional TTL.
	// The message field must contain a PutAllRequest that contains the
	// serialized keys and values and optional TTL.
	// The response will just be a Complete message corresponding to the request id.
	NamedCacheRequestType_PutAll NamedCacheRequestType = 18
	// Add a key and value to the cache if a value is not already mapped to the key.
	// The message field should contain a PutRequest that contains the
	// serialized key, serialized value.
	// The response will contain the Cache Id and an BytesValue that will contain the
	// serialized previous value mapped to the key.
	NamedCacheRequestType_PutIfAbsent NamedCacheRequestType = 19
	// Execute a query for cache entries
	// The message field must contain a QueryRequest
	// The response will be a stream of BinaryKeyAndValue representing each cache entry
	// in the results of the query, finally followed by a Complete message to signal
	// the end of the response stream.
	NamedCacheRequestType_QueryEntries NamedCacheRequestType = 20
	// Execute a query for cache keys
	// The message field must contain a QueryRequest
	// The response will be a stream of BytesValue representing each cache key in
	// the results of the query, finally followed by a Complete message to signal
	// the end of the response stream.
	NamedCacheRequestType_QueryKeys NamedCacheRequestType = 21
	// Execute a query for cache values
	// The message field must contain a QueryRequest
	// The response will be a stream of BytesValue representing each cache value in
	// the results of the query, finally followed by a Complete message to signal
	// the end of the response stream.
	NamedCacheRequestType_QueryValues NamedCacheRequestType = 22
	// Remove an entry from the cache.
	// The message field must contain a BytesValue that contains the
	// serialized key of the entry to remove.
	// The response will contain the Cache Id and an BytesValue that will be empty
	// if the cache did not contain an entry for the key or will contain the value from
	// the cache.
	NamedCacheRequestType_Remove NamedCacheRequestType = 23
	// Remove an entry from the cache if the specified key maps to the specified value.
	// The message field must contain a BinaryKeyAndValue that contains the
	// serialized key and expected value of the entry to remove.
	// The response will contain the Cache Id and an BoolValue that will true if the
	// entry was removed.
	NamedCacheRequestType_RemoveMapping NamedCacheRequestType = 24
	// Replace an entry in the cache only if the key is currently mapped to a value.
	// The message field must contain a BinaryKeyAndValue that contains the
	// serialized key of the entry to replace and the serialized value to map to the
	// key.
	// The response will contain the Cache Id and an BytesValue that will contain the
	// serialized previous value mapped to the key.
	NamedCacheRequestType_Replace NamedCacheRequestType = 25
	// Replace an entry in the cache only if the key is currently mapped to a
	// specified value.
	// The message field must contain a ReplaceMappingRequest that contains the
	// serialized key of the entry to replace, the serialized expected value and the
	// serialized new value to map to the key.
	// The response will contain the Cache Id and an BoolValue that will be true if
	// the cache mapping was updated.
	NamedCacheRequestType_ReplaceMapping NamedCacheRequestType = 26
	// Obtain the size of the specified cache.
	// The message field should not be set.
	// The response will contain the Cache Id and an Int32Value in the response field.
	NamedCacheRequestType_Size NamedCacheRequestType = 27
	// Truncate the specified cache.
	// The message field should not be set.
	// The response will just be a Complete message corresponding to the request id.
	NamedCacheRequestType_Truncate NamedCacheRequestType = 28
)

// Enum value maps for NamedCacheRequestType.
var (
	NamedCacheRequestType_name = map[int32]string{
		0:  "Unknown",
		1:  "EnsureCache",
		2:  "Aggregate",
		3:  "Clear",
		4:  "ContainsEntry",
		5:  "ContainsKey",
		6:  "ContainsValue",
		7:  "Destroy",
		8:  "IsEmpty",
		9:  "IsReady",
		10: "Get",
		11: "GetAll",
		12: "Index",
		13: "Invoke",
		14: "MapListener",
		15: "PageOfEntries",
		16: "PageOfKeys",
		17: "Put",
		18: "PutAll",
		19: "PutIfAbsent",
		20: "QueryEntries",
		21: "QueryKeys",
		22: "QueryValues",
		23: "Remove",
		24: "RemoveMapping",
		25: "Replace",
		26: "ReplaceMapping",
		27: "Size",
		28: "Truncate",
	}
	NamedCacheRequestType_value = map[string]int32{
		"Unknown":        0,
		"EnsureCache":    1,
		"Aggregate":      2,
		"Clear":          3,
		"ContainsEntry":  4,
		"ContainsKey":    5,
		"ContainsValue":  6,
		"Destroy":        7,
		"IsEmpty":        8,
		"IsReady":        9,
		"Get":            10,
		"GetAll":         11,
		"Index":          12,
		"Invoke":         13,
		"MapListener":    14,
		"PageOfEntries":  15,
		"PageOfKeys":     16,
		"Put":            17,
		"PutAll":         18,
		"PutIfAbsent":    19,
		"QueryEntries":   20,
		"QueryKeys":      21,
		"QueryValues":    22,
		"Remove":         23,
		"RemoveMapping":  24,
		"Replace":        25,
		"ReplaceMapping": 26,
		"Size":           27,
		"Truncate":       28,
	}
)

func (x NamedCacheRequestType) Enum() *NamedCacheRequestType {
	p := new(NamedCacheRequestType)
	*p = x
	return p
}

func (x NamedCacheRequestType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NamedCacheRequestType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_service_messages_v1_proto_enumTypes[0].Descriptor()
}

func (NamedCacheRequestType) Type() protoreflect.EnumType {
	return &file_cache_service_messages_v1_proto_enumTypes[0]
}

func (x NamedCacheRequestType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NamedCacheRequestType.Descriptor instead.
func (NamedCacheRequestType) EnumDescriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{0}
}

// An enum representing different types of response.
//
// NOTE: The index numbers for the enum elements MUST NOT BE CHANGED as
// that would break backwards compatibility. Only new index numbers can
// be added.
type ResponseType int32

const (
	// The response is a message.
	ResponseType_Message ResponseType = 0
	// The response is a map event.
	ResponseType_MapEvent ResponseType = 1
	// The response is destroy event
	ResponseType_Destroyed ResponseType = 2
	// The response is truncated event
	ResponseType_Truncated ResponseType = 3
)

// Enum value maps for ResponseType.
var (
	ResponseType_name = map[int32]string{
		0: "Message",
		1: "MapEvent",
		2: "Destroyed",
		3: "Truncated",
	}
	ResponseType_value = map[string]int32{
		"Message":   0,
		"MapEvent":  1,
		"Destroyed": 2,
		"Truncated": 3,
	}
)

func (x ResponseType) Enum() *ResponseType {
	p := new(ResponseType)
	*p = x
	return p
}

func (x ResponseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResponseType) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_service_messages_v1_proto_enumTypes[1].Descriptor()
}

func (ResponseType) Type() protoreflect.EnumType {
	return &file_cache_service_messages_v1_proto_enumTypes[1]
}

func (x ResponseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResponseType.Descriptor instead.
func (ResponseType) EnumDescriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{1}
}

// An enum of TransformationState values to describes how a CacheEvent has been or should be transformed.
type MapEventMessage_TransformationState int32

const (
	// Value used to indicate that an event is non-transformable and should
	// not be passed to any transformer-based listeners.
	MapEventMessage_NON_TRANSFORMABLE MapEventMessage_TransformationState = 0
	// Value used to indicate that an event is transformable and could be
	// passed to transformer-based listeners.
	MapEventMessage_TRANSFORMABLE MapEventMessage_TransformationState = 1
	// Value used to indicate that an event has been transformed, and should
	// only be passed to transformer-based listeners.
	MapEventMessage_TRANSFORMED MapEventMessage_TransformationState = 2
)

// Enum value maps for MapEventMessage_TransformationState.
var (
	MapEventMessage_TransformationState_name = map[int32]string{
		0: "NON_TRANSFORMABLE",
		1: "TRANSFORMABLE",
		2: "TRANSFORMED",
	}
	MapEventMessage_TransformationState_value = map[string]int32{
		"NON_TRANSFORMABLE": 0,
		"TRANSFORMABLE":     1,
		"TRANSFORMED":       2,
	}
)

func (x MapEventMessage_TransformationState) Enum() *MapEventMessage_TransformationState {
	p := new(MapEventMessage_TransformationState)
	*p = x
	return p
}

func (x MapEventMessage_TransformationState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MapEventMessage_TransformationState) Descriptor() protoreflect.EnumDescriptor {
	return file_cache_service_messages_v1_proto_enumTypes[2].Descriptor()
}

func (MapEventMessage_TransformationState) Type() protoreflect.EnumType {
	return &file_cache_service_messages_v1_proto_enumTypes[2]
}

func (x MapEventMessage_TransformationState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MapEventMessage_TransformationState.Descriptor instead.
func (MapEventMessage_TransformationState) EnumDescriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{12, 0}
}

// A request to perform an operation on a remote NamedCache.
type NamedCacheRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the request
	Type NamedCacheRequestType `protobuf:"varint,1,opt,name=type,proto3,enum=coherence.cache.v1.NamedCacheRequestType" json:"type,omitempty"`
	// The cache identifier for the request.
	// The identifier must be the same value returned by the initial ensure cache request.
	// This is optional only for EnsureCache as this cannot have a cache identifier
	CacheId *int32 `protobuf:"varint,2,opt,name=cacheId,proto3,oneof" json:"cacheId,omitempty"`
	// The actual request message, this is optional because some messages do not require
	// a message body, for example cache.size()
	// The actual request message should be packed inside an Any message and set in this field.
	// The proxy will know which message type to expect here based on the "type" field's value.
	Message       *anypb.Any `protobuf:"bytes,3,opt,name=message,proto3,oneof" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NamedCacheRequest) Reset() {
	*x = NamedCacheRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NamedCacheRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NamedCacheRequest) ProtoMessage() {}

func (x *NamedCacheRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NamedCacheRequest.ProtoReflect.Descriptor instead.
func (*NamedCacheRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{0}
}

func (x *NamedCacheRequest) GetType() NamedCacheRequestType {
	if x != nil {
		return x.Type
	}
	return NamedCacheRequestType_Unknown
}

func (x *NamedCacheRequest) GetCacheId() int32 {
	if x != nil && x.CacheId != nil {
		return *x.CacheId
	}
	return 0
}

func (x *NamedCacheRequest) GetMessage() *anypb.Any {
	if x != nil {
		return x.Message
	}
	return nil
}

// A response message from a Named Cache Service proxy.
//
// NOTE: If you add a new request message to this message the protocol
// version in com.oracle.coherence.grpc.NamedCacheProtocol must be
// increased. This only needs to be done once for any given Coherence
// release.
type NamedCacheResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cache identifier for the request
	CacheId int32 `protobuf:"varint,1,opt,name=cacheId,proto3" json:"cacheId,omitempty"`
	// An enum representing different response types.
	// The type of the request.
	Type ResponseType `protobuf:"varint,2,opt,name=type,proto3,enum=coherence.cache.v1.ResponseType" json:"type,omitempty"`
	// The response can contain one of a number of response types
	// The sender of the corresponding request should know which
	// response type it expects
	Message       *anypb.Any `protobuf:"bytes,3,opt,name=message,proto3,oneof" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NamedCacheResponse) Reset() {
	*x = NamedCacheResponse{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NamedCacheResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NamedCacheResponse) ProtoMessage() {}

func (x *NamedCacheResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NamedCacheResponse.ProtoReflect.Descriptor instead.
func (*NamedCacheResponse) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{1}
}

func (x *NamedCacheResponse) GetCacheId() int32 {
	if x != nil {
		return x.CacheId
	}
	return 0
}

func (x *NamedCacheResponse) GetType() ResponseType {
	if x != nil {
		return x.Type
	}
	return ResponseType_Message
}

func (x *NamedCacheResponse) GetMessage() *anypb.Any {
	if x != nil {
		return x.Message
	}
	return nil
}

// A request to ensure a specific cache.
type EnsureCacheRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the cache.
	Cache         string `protobuf:"bytes,1,opt,name=cache,proto3" json:"cache,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureCacheRequest) Reset() {
	*x = EnsureCacheRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureCacheRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureCacheRequest) ProtoMessage() {}

func (x *EnsureCacheRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureCacheRequest.ProtoReflect.Descriptor instead.
func (*EnsureCacheRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{2}
}

func (x *EnsureCacheRequest) GetCache() string {
	if x != nil {
		return x.Cache
	}
	return ""
}

// A request to associate the specified value with the
// specified key in a cache with an optional TTL.
type PutRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cache entry key.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The value of the entry.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// The time to live in millis.
	Ttl           *int64 `protobuf:"varint,3,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutRequest) Reset() {
	*x = PutRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutRequest) ProtoMessage() {}

func (x *PutRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutRequest.ProtoReflect.Descriptor instead.
func (*PutRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{3}
}

func (x *PutRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *PutRequest) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PutRequest) GetTtl() int64 {
	if x != nil && x.Ttl != nil {
		return *x.Ttl
	}
	return 0
}

// A request to associate the specified value with the
// specified key in a cache with an optional TTL.
type PutAllRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The cache entries to put.
	Entries []*BinaryKeyAndValue `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	// The time to live in millis.
	Ttl           *int64 `protobuf:"varint,2,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PutAllRequest) Reset() {
	*x = PutAllRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PutAllRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PutAllRequest) ProtoMessage() {}

func (x *PutAllRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PutAllRequest.ProtoReflect.Descriptor instead.
func (*PutAllRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{4}
}

func (x *PutAllRequest) GetEntries() []*BinaryKeyAndValue {
	if x != nil {
		return x.Entries
	}
	return nil
}

func (x *PutAllRequest) GetTtl() int64 {
	if x != nil && x.Ttl != nil {
		return *x.Ttl
	}
	return 0
}

// A request to replace the mapping for the specified key
// with the specified newValue in a cache only if the specified
// key is associated with the specified previousValue in
// that cache.
type ReplaceMappingRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The key of the entry to be replaced.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The previous value that should exist in the cache.
	PreviousValue []byte `protobuf:"bytes,2,opt,name=previousValue,proto3" json:"previousValue,omitempty"`
	// The new value to put.
	NewValue      []byte `protobuf:"bytes,3,opt,name=newValue,proto3" json:"newValue,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplaceMappingRequest) Reset() {
	*x = ReplaceMappingRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplaceMappingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceMappingRequest) ProtoMessage() {}

func (x *ReplaceMappingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceMappingRequest.ProtoReflect.Descriptor instead.
func (*ReplaceMappingRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{5}
}

func (x *ReplaceMappingRequest) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *ReplaceMappingRequest) GetPreviousValue() []byte {
	if x != nil {
		return x.PreviousValue
	}
	return nil
}

func (x *ReplaceMappingRequest) GetNewValue() []byte {
	if x != nil {
		return x.NewValue
	}
	return nil
}

// A request to add or remove an index to a cache
type IndexRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// True to add an index, false to remove an index
	Add bool `protobuf:"varint,1,opt,name=add,proto3" json:"add,omitempty"`
	// The serialized ValueExtractor to use to create or remove the index.
	Extractor []byte `protobuf:"bytes,2,opt,name=extractor,proto3" json:"extractor,omitempty"`
	// A flag indicating whether to sort the index.
	// This is not required for index removal.
	Sorted *bool `protobuf:"varint,3,opt,name=sorted,proto3,oneof" json:"sorted,omitempty"`
	// The optional comparator to use to sort the index.
	// This is not required for index removal.
	Comparator    []byte `protobuf:"bytes,4,opt,name=comparator,proto3,oneof" json:"comparator,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexRequest) Reset() {
	*x = IndexRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexRequest) ProtoMessage() {}

func (x *IndexRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexRequest.ProtoReflect.Descriptor instead.
func (*IndexRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{6}
}

func (x *IndexRequest) GetAdd() bool {
	if x != nil {
		return x.Add
	}
	return false
}

func (x *IndexRequest) GetExtractor() []byte {
	if x != nil {
		return x.Extractor
	}
	return nil
}

func (x *IndexRequest) GetSorted() bool {
	if x != nil && x.Sorted != nil {
		return *x.Sorted
	}
	return false
}

func (x *IndexRequest) GetComparator() []byte {
	if x != nil {
		return x.Comparator
	}
	return nil
}

// A message containing either a single serialized key, or a
// collection of serialized keys, or a serialized Filter.
type KeysOrFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to KeyOrFilter:
	//
	//	*KeysOrFilter_Key
	//	*KeysOrFilter_Keys
	//	*KeysOrFilter_Filter
	KeyOrFilter   isKeysOrFilter_KeyOrFilter `protobuf_oneof:"keyOrFilter"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeysOrFilter) Reset() {
	*x = KeysOrFilter{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeysOrFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeysOrFilter) ProtoMessage() {}

func (x *KeysOrFilter) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeysOrFilter.ProtoReflect.Descriptor instead.
func (*KeysOrFilter) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{7}
}

func (x *KeysOrFilter) GetKeyOrFilter() isKeysOrFilter_KeyOrFilter {
	if x != nil {
		return x.KeyOrFilter
	}
	return nil
}

func (x *KeysOrFilter) GetKey() []byte {
	if x != nil {
		if x, ok := x.KeyOrFilter.(*KeysOrFilter_Key); ok {
			return x.Key
		}
	}
	return nil
}

func (x *KeysOrFilter) GetKeys() *CollectionOfBytesValues {
	if x != nil {
		if x, ok := x.KeyOrFilter.(*KeysOrFilter_Keys); ok {
			return x.Keys
		}
	}
	return nil
}

func (x *KeysOrFilter) GetFilter() []byte {
	if x != nil {
		if x, ok := x.KeyOrFilter.(*KeysOrFilter_Filter); ok {
			return x.Filter
		}
	}
	return nil
}

type isKeysOrFilter_KeyOrFilter interface {
	isKeysOrFilter_KeyOrFilter()
}

type KeysOrFilter_Key struct {
	// A single serialized key
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}

type KeysOrFilter_Keys struct {
	// The collection of serialized keys
	Keys *CollectionOfBytesValues `protobuf:"bytes,2,opt,name=keys,proto3,oneof"`
}

type KeysOrFilter_Filter struct {
	// The serialized filter
	Filter []byte `protobuf:"bytes,3,opt,name=filter,proto3,oneof"`
}

func (*KeysOrFilter_Key) isKeysOrFilter_KeyOrFilter() {}

func (*KeysOrFilter_Keys) isKeysOrFilter_KeyOrFilter() {}

func (*KeysOrFilter_Filter) isKeysOrFilter_KeyOrFilter() {}

// A message containing either a single serialized key,
// or a serialized Filter.
type KeyOrFilter struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to KeyOrFilter:
	//
	//	*KeyOrFilter_Key
	//	*KeyOrFilter_Filter
	KeyOrFilter   isKeyOrFilter_KeyOrFilter `protobuf_oneof:"keyOrFilter"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyOrFilter) Reset() {
	*x = KeyOrFilter{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyOrFilter) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyOrFilter) ProtoMessage() {}

func (x *KeyOrFilter) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyOrFilter.ProtoReflect.Descriptor instead.
func (*KeyOrFilter) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{8}
}

func (x *KeyOrFilter) GetKeyOrFilter() isKeyOrFilter_KeyOrFilter {
	if x != nil {
		return x.KeyOrFilter
	}
	return nil
}

func (x *KeyOrFilter) GetKey() []byte {
	if x != nil {
		if x, ok := x.KeyOrFilter.(*KeyOrFilter_Key); ok {
			return x.Key
		}
	}
	return nil
}

func (x *KeyOrFilter) GetFilter() []byte {
	if x != nil {
		if x, ok := x.KeyOrFilter.(*KeyOrFilter_Filter); ok {
			return x.Filter
		}
	}
	return nil
}

type isKeyOrFilter_KeyOrFilter interface {
	isKeyOrFilter_KeyOrFilter()
}

type KeyOrFilter_Key struct {
	// A single serialized key
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}

type KeyOrFilter_Filter struct {
	// The serialized filter
	Filter []byte `protobuf:"bytes,2,opt,name=filter,proto3,oneof"`
}

func (*KeyOrFilter_Key) isKeyOrFilter_KeyOrFilter() {}

func (*KeyOrFilter_Filter) isKeyOrFilter_KeyOrFilter() {}

// A request to aggregate entries in a cache.
type ExecuteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The serialized executable agent (for example an entry processor or aggregator).
	Agent []byte `protobuf:"bytes,1,opt,name=agent,proto3" json:"agent,omitempty"`
	// The optional collection of keys or filter to use to execute the agent.
	Keys          *KeysOrFilter `protobuf:"bytes,3,opt,name=keys,proto3,oneof" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteRequest) Reset() {
	*x = ExecuteRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteRequest) ProtoMessage() {}

func (x *ExecuteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteRequest.ProtoReflect.Descriptor instead.
func (*ExecuteRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{9}
}

func (x *ExecuteRequest) GetAgent() []byte {
	if x != nil {
		return x.Agent
	}
	return nil
}

func (x *ExecuteRequest) GetKeys() *KeysOrFilter {
	if x != nil {
		return x.Keys
	}
	return nil
}

// A request cache query request.
type QueryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The serialized Filter to identify the data to return.
	Filter []byte `protobuf:"bytes,1,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
	// The optional comparator to use to sort the returned data.
	Comparator    []byte `protobuf:"bytes,2,opt,name=comparator,proto3,oneof" json:"comparator,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryRequest) Reset() {
	*x = QueryRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryRequest) ProtoMessage() {}

func (x *QueryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryRequest.ProtoReflect.Descriptor instead.
func (*QueryRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{10}
}

func (x *QueryRequest) GetFilter() []byte {
	if x != nil {
		return x.Filter
	}
	return nil
}

func (x *QueryRequest) GetComparator() []byte {
	if x != nil {
		return x.Comparator
	}
	return nil
}

// A message to subscribe to or unsubscribe from MapEvents for a cache.
type MapListenerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A flag indicating whether to subscribe to (true) or unsubscribe from (false) events.
	Subscribe bool `protobuf:"varint,1,opt,name=subscribe,proto3" json:"subscribe,omitempty"`
	// The optional serialized key, or serialized Filter, to identify the entry
	// (or entries) to subscribe to.
	// If neither key nor filter are set then an Always filter will be used.
	KeyOrFilter *KeyOrFilter `protobuf:"bytes,2,opt,name=keyOrFilter,proto3,oneof" json:"keyOrFilter,omitempty"`
	// A unique filter identifier used if the keyOrFilter contains a Filter.
	FilterId int64 `protobuf:"varint,3,opt,name=filterId,proto3" json:"filterId,omitempty"`
	// A flag set to true to indicate that the MapEvent objects do
	// not have to include the OldValue and NewValue property values
	// in order to allow optimizations
	Lite bool `protobuf:"varint,4,opt,name=lite,proto3" json:"lite,omitempty"`
	// Whether the listener is synchronous
	Synchronous bool `protobuf:"varint,5,opt,name=synchronous,proto3" json:"synchronous,omitempty"`
	// A flag set to true to indicate that the listener is a priming listener.
	// A priming listener can only be used when the keyOrFilter field contains
	// a single key, or an InKeySetFilter.
	Priming bool `protobuf:"varint,6,opt,name=priming,proto3" json:"priming,omitempty"`
	// An optional serialized MapTrigger.
	Trigger       []byte `protobuf:"bytes,7,opt,name=trigger,proto3" json:"trigger,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapListenerRequest) Reset() {
	*x = MapListenerRequest{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapListenerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapListenerRequest) ProtoMessage() {}

func (x *MapListenerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapListenerRequest.ProtoReflect.Descriptor instead.
func (*MapListenerRequest) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{11}
}

func (x *MapListenerRequest) GetSubscribe() bool {
	if x != nil {
		return x.Subscribe
	}
	return false
}

func (x *MapListenerRequest) GetKeyOrFilter() *KeyOrFilter {
	if x != nil {
		return x.KeyOrFilter
	}
	return nil
}

func (x *MapListenerRequest) GetFilterId() int64 {
	if x != nil {
		return x.FilterId
	}
	return 0
}

func (x *MapListenerRequest) GetLite() bool {
	if x != nil {
		return x.Lite
	}
	return false
}

func (x *MapListenerRequest) GetSynchronous() bool {
	if x != nil {
		return x.Synchronous
	}
	return false
}

func (x *MapListenerRequest) GetPriming() bool {
	if x != nil {
		return x.Priming
	}
	return false
}

func (x *MapListenerRequest) GetTrigger() []byte {
	if x != nil {
		return x.Trigger
	}
	return nil
}

// A response containing a MapEvent for a MapListener
type MapEventMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The type of the event
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The key of the entry
	Key []byte `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	// The new value of the entry
	NewValue []byte `protobuf:"bytes,3,opt,name=newValue,proto3" json:"newValue,omitempty"`
	// The old value of the entry
	OldValue []byte `protobuf:"bytes,4,opt,name=oldValue,proto3" json:"oldValue,omitempty"`
	// TransformationState describes how a CacheEvent has been or should be transformed.
	TransformationState MapEventMessage_TransformationState `protobuf:"varint,5,opt,name=transformationState,proto3,enum=coherence.cache.v1.MapEventMessage_TransformationState" json:"transformationState,omitempty"`
	// The Filter identifiers applicable to the event.
	FilterIds []int64 `protobuf:"varint,6,rep,packed,name=filterIds,proto3" json:"filterIds,omitempty"`
	// A flag indicating whether the event is a synthetic event.
	Synthetic bool `protobuf:"varint,7,opt,name=synthetic,proto3" json:"synthetic,omitempty"`
	// A flag indicating whether the event is a priming event.
	Priming bool `protobuf:"varint,8,opt,name=priming,proto3" json:"priming,omitempty"`
	// A flag indicating whether this is an expiry event.
	Expired bool `protobuf:"varint,9,opt,name=expired,proto3" json:"expired,omitempty"`
	// true iff this event is caused by a synthetic version update sent
	// by the server to notify clients of the current version.
	VersionUpdate bool `protobuf:"varint,10,opt,name=versionUpdate,proto3" json:"versionUpdate,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MapEventMessage) Reset() {
	*x = MapEventMessage{}
	mi := &file_cache_service_messages_v1_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MapEventMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MapEventMessage) ProtoMessage() {}

func (x *MapEventMessage) ProtoReflect() protoreflect.Message {
	mi := &file_cache_service_messages_v1_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MapEventMessage.ProtoReflect.Descriptor instead.
func (*MapEventMessage) Descriptor() ([]byte, []int) {
	return file_cache_service_messages_v1_proto_rawDescGZIP(), []int{12}
}

func (x *MapEventMessage) GetId() int32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *MapEventMessage) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *MapEventMessage) GetNewValue() []byte {
	if x != nil {
		return x.NewValue
	}
	return nil
}

func (x *MapEventMessage) GetOldValue() []byte {
	if x != nil {
		return x.OldValue
	}
	return nil
}

func (x *MapEventMessage) GetTransformationState() MapEventMessage_TransformationState {
	if x != nil {
		return x.TransformationState
	}
	return MapEventMessage_NON_TRANSFORMABLE
}

func (x *MapEventMessage) GetFilterIds() []int64 {
	if x != nil {
		return x.FilterIds
	}
	return nil
}

func (x *MapEventMessage) GetSynthetic() bool {
	if x != nil {
		return x.Synthetic
	}
	return false
}

func (x *MapEventMessage) GetPriming() bool {
	if x != nil {
		return x.Priming
	}
	return false
}

func (x *MapEventMessage) GetExpired() bool {
	if x != nil {
		return x.Expired
	}
	return false
}

func (x *MapEventMessage) GetVersionUpdate() bool {
	if x != nil {
		return x.VersionUpdate
	}
	return false
}

var File_cache_service_messages_v1_proto protoreflect.FileDescriptor

const file_cache_service_messages_v1_proto_rawDesc = "" +
	"\n" +
	"\x1fcache_service_messages_v1.proto\x12\x12coherence.cache.v1\x1a\x18common_messages_v1.proto\x1a\x19google/protobuf/any.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xbe\x01\n" +
	"\x11NamedCacheRequest\x12=\n" +
	"\x04type\x18\x01 \x01(\x0e2).coherence.cache.v1.NamedCacheRequestTypeR\x04type\x12\x1d\n" +
	"\acacheId\x18\x02 \x01(\x05H\x00R\acacheId\x88\x01\x01\x123\n" +
	"\amessage\x18\x03 \x01(\v2\x14.google.protobuf.AnyH\x01R\amessage\x88\x01\x01B\n" +
	"\n" +
	"\b_cacheIdB\n" +
	"\n" +
	"\b_message\"\xa5\x01\n" +
	"\x12NamedCacheResponse\x12\x18\n" +
	"\acacheId\x18\x01 \x01(\x05R\acacheId\x124\n" +
	"\x04type\x18\x02 \x01(\x0e2 .coherence.cache.v1.ResponseTypeR\x04type\x123\n" +
	"\amessage\x18\x03 \x01(\v2\x14.google.protobuf.AnyH\x00R\amessage\x88\x01\x01B\n" +
	"\n" +
	"\b_message\"*\n" +
	"\x12EnsureCacheRequest\x12\x14\n" +
	"\x05cache\x18\x01 \x01(\tR\x05cache\"S\n" +
	"\n" +
	"PutRequest\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value\x12\x15\n" +
	"\x03ttl\x18\x03 \x01(\x03H\x00R\x03ttl\x88\x01\x01B\x06\n" +
	"\x04_ttl\"p\n" +
	"\rPutAllRequest\x12@\n" +
	"\aentries\x18\x01 \x03(\v2&.coherence.common.v1.BinaryKeyAndValueR\aentries\x12\x15\n" +
	"\x03ttl\x18\x02 \x01(\x03H\x00R\x03ttl\x88\x01\x01B\x06\n" +
	"\x04_ttl\"k\n" +
	"\x15ReplaceMappingRequest\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12$\n" +
	"\rpreviousValue\x18\x02 \x01(\fR\rpreviousValue\x12\x1a\n" +
	"\bnewValue\x18\x03 \x01(\fR\bnewValue\"\x9a\x01\n" +
	"\fIndexRequest\x12\x10\n" +
	"\x03add\x18\x01 \x01(\bR\x03add\x12\x1c\n" +
	"\textractor\x18\x02 \x01(\fR\textractor\x12\x1b\n" +
	"\x06sorted\x18\x03 \x01(\bH\x00R\x06sorted\x88\x01\x01\x12#\n" +
	"\n" +
	"comparator\x18\x04 \x01(\fH\x01R\n" +
	"comparator\x88\x01\x01B\t\n" +
	"\a_sortedB\r\n" +
	"\v_comparator\"\x8f\x01\n" +
	"\fKeysOrFilter\x12\x12\n" +
	"\x03key\x18\x01 \x01(\fH\x00R\x03key\x12B\n" +
	"\x04keys\x18\x02 \x01(\v2,.coherence.common.v1.CollectionOfBytesValuesH\x00R\x04keys\x12\x18\n" +
	"\x06filter\x18\x03 \x01(\fH\x00R\x06filterB\r\n" +
	"\vkeyOrFilter\"J\n" +
	"\vKeyOrFilter\x12\x12\n" +
	"\x03key\x18\x01 \x01(\fH\x00R\x03key\x12\x18\n" +
	"\x06filter\x18\x02 \x01(\fH\x00R\x06filterB\r\n" +
	"\vkeyOrFilter\"j\n" +
	"\x0eExecuteRequest\x12\x14\n" +
	"\x05agent\x18\x01 \x01(\fR\x05agent\x129\n" +
	"\x04keys\x18\x03 \x01(\v2 .coherence.cache.v1.KeysOrFilterH\x00R\x04keys\x88\x01\x01B\a\n" +
	"\x05_keys\"j\n" +
	"\fQueryRequest\x12\x1b\n" +
	"\x06filter\x18\x01 \x01(\fH\x00R\x06filter\x88\x01\x01\x12#\n" +
	"\n" +
	"comparator\x18\x02 \x01(\fH\x01R\n" +
	"comparator\x88\x01\x01B\t\n" +
	"\a_filterB\r\n" +
	"\v_comparator\"\x90\x02\n" +
	"\x12MapListenerRequest\x12\x1c\n" +
	"\tsubscribe\x18\x01 \x01(\bR\tsubscribe\x12F\n" +
	"\vkeyOrFilter\x18\x02 \x01(\v2\x1f.coherence.cache.v1.KeyOrFilterH\x00R\vkeyOrFilter\x88\x01\x01\x12\x1a\n" +
	"\bfilterId\x18\x03 \x01(\x03R\bfilterId\x12\x12\n" +
	"\x04lite\x18\x04 \x01(\bR\x04lite\x12 \n" +
	"\vsynchronous\x18\x05 \x01(\bR\vsynchronous\x12\x18\n" +
	"\apriming\x18\x06 \x01(\bR\apriming\x12\x18\n" +
	"\atrigger\x18\a \x01(\fR\atriggerB\x0e\n" +
	"\f_keyOrFilter\"\xbe\x03\n" +
	"\x0fMapEventMessage\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\x05R\x02id\x12\x10\n" +
	"\x03key\x18\x02 \x01(\fR\x03key\x12\x1a\n" +
	"\bnewValue\x18\x03 \x01(\fR\bnewValue\x12\x1a\n" +
	"\boldValue\x18\x04 \x01(\fR\boldValue\x12i\n" +
	"\x13transformationState\x18\x05 \x01(\x0e27.coherence.cache.v1.MapEventMessage.TransformationStateR\x13transformationState\x12\x1c\n" +
	"\tfilterIds\x18\x06 \x03(\x03R\tfilterIds\x12\x1c\n" +
	"\tsynthetic\x18\a \x01(\bR\tsynthetic\x12\x18\n" +
	"\apriming\x18\b \x01(\bR\apriming\x12\x18\n" +
	"\aexpired\x18\t \x01(\bR\aexpired\x12$\n" +
	"\rversionUpdate\x18\n" +
	" \x01(\bR\rversionUpdate\"P\n" +
	"\x13TransformationState\x12\x15\n" +
	"\x11NON_TRANSFORMABLE\x10\x00\x12\x11\n" +
	"\rTRANSFORMABLE\x10\x01\x12\x0f\n" +
	"\vTRANSFORMED\x10\x02*\xbd\x03\n" +
	"\x15NamedCacheRequestType\x12\v\n" +
	"\aUnknown\x10\x00\x12\x0f\n" +
	"\vEnsureCache\x10\x01\x12\r\n" +
	"\tAggregate\x10\x02\x12\t\n" +
	"\x05Clear\x10\x03\x12\x11\n" +
	"\rContainsEntry\x10\x04\x12\x0f\n" +
	"\vContainsKey\x10\x05\x12\x11\n" +
	"\rContainsValue\x10\x06\x12\v\n" +
	"\aDestroy\x10\a\x12\v\n" +
	"\aIsEmpty\x10\b\x12\v\n" +
	"\aIsReady\x10\t\x12\a\n" +
	"\x03Get\x10\n" +
	"\x12\n" +
	"\n" +
	"\x06GetAll\x10\v\x12\t\n" +
	"\x05Index\x10\f\x12\n" +
	"\n" +
	"\x06Invoke\x10\r\x12\x0f\n" +
	"\vMapListener\x10\x0e\x12\x11\n" +
	"\rPageOfEntries\x10\x0f\x12\x0e\n" +
	"\n" +
	"PageOfKeys\x10\x10\x12\a\n" +
	"\x03Put\x10\x11\x12\n" +
	"\n" +
	"\x06PutAll\x10\x12\x12\x0f\n" +
	"\vPutIfAbsent\x10\x13\x12\x10\n" +
	"\fQueryEntries\x10\x14\x12\r\n" +
	"\tQueryKeys\x10\x15\x12\x0f\n" +
	"\vQueryValues\x10\x16\x12\n" +
	"\n" +
	"\x06Remove\x10\x17\x12\x11\n" +
	"\rRemoveMapping\x10\x18\x12\v\n" +
	"\aReplace\x10\x19\x12\x12\n" +
	"\x0eReplaceMapping\x10\x1a\x12\b\n" +
	"\x04Size\x10\x1b\x12\f\n" +
	"\bTruncate\x10\x1c*G\n" +
	"\fResponseType\x12\v\n" +
	"\aMessage\x10\x00\x12\f\n" +
	"\bMapEvent\x10\x01\x12\r\n" +
	"\tDestroyed\x10\x02\x12\r\n" +
	"\tTruncated\x10\x03B_\n" +
	"+com.oracle.coherence.grpc.messages.cache.v1P\x01Z.github.com/oracle/coherence-go-client/proto/v1b\x06proto3"

var (
	file_cache_service_messages_v1_proto_rawDescOnce sync.Once
	file_cache_service_messages_v1_proto_rawDescData []byte
)

func file_cache_service_messages_v1_proto_rawDescGZIP() []byte {
	file_cache_service_messages_v1_proto_rawDescOnce.Do(func() {
		file_cache_service_messages_v1_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_cache_service_messages_v1_proto_rawDesc), len(file_cache_service_messages_v1_proto_rawDesc)))
	})
	return file_cache_service_messages_v1_proto_rawDescData
}

var file_cache_service_messages_v1_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_cache_service_messages_v1_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_cache_service_messages_v1_proto_goTypes = []any{
	(NamedCacheRequestType)(0),               // 0: coherence.cache.v1.NamedCacheRequestType
	(ResponseType)(0),                        // 1: coherence.cache.v1.ResponseType
	(MapEventMessage_TransformationState)(0), // 2: coherence.cache.v1.MapEventMessage.TransformationState
	(*NamedCacheRequest)(nil),                // 3: coherence.cache.v1.NamedCacheRequest
	(*NamedCacheResponse)(nil),               // 4: coherence.cache.v1.NamedCacheResponse
	(*EnsureCacheRequest)(nil),               // 5: coherence.cache.v1.EnsureCacheRequest
	(*PutRequest)(nil),                       // 6: coherence.cache.v1.PutRequest
	(*PutAllRequest)(nil),                    // 7: coherence.cache.v1.PutAllRequest
	(*ReplaceMappingRequest)(nil),            // 8: coherence.cache.v1.ReplaceMappingRequest
	(*IndexRequest)(nil),                     // 9: coherence.cache.v1.IndexRequest
	(*KeysOrFilter)(nil),                     // 10: coherence.cache.v1.KeysOrFilter
	(*KeyOrFilter)(nil),                      // 11: coherence.cache.v1.KeyOrFilter
	(*ExecuteRequest)(nil),                   // 12: coherence.cache.v1.ExecuteRequest
	(*QueryRequest)(nil),                     // 13: coherence.cache.v1.QueryRequest
	(*MapListenerRequest)(nil),               // 14: coherence.cache.v1.MapListenerRequest
	(*MapEventMessage)(nil),                  // 15: coherence.cache.v1.MapEventMessage
	(*anypb.Any)(nil),                        // 16: google.protobuf.Any
	(*BinaryKeyAndValue)(nil),                // 17: coherence.common.v1.BinaryKeyAndValue
	(*CollectionOfBytesValues)(nil),          // 18: coherence.common.v1.CollectionOfBytesValues
}
var file_cache_service_messages_v1_proto_depIdxs = []int32{
	0,  // 0: coherence.cache.v1.NamedCacheRequest.type:type_name -> coherence.cache.v1.NamedCacheRequestType
	16, // 1: coherence.cache.v1.NamedCacheRequest.message:type_name -> google.protobuf.Any
	1,  // 2: coherence.cache.v1.NamedCacheResponse.type:type_name -> coherence.cache.v1.ResponseType
	16, // 3: coherence.cache.v1.NamedCacheResponse.message:type_name -> google.protobuf.Any
	17, // 4: coherence.cache.v1.PutAllRequest.entries:type_name -> coherence.common.v1.BinaryKeyAndValue
	18, // 5: coherence.cache.v1.KeysOrFilter.keys:type_name -> coherence.common.v1.CollectionOfBytesValues
	10, // 6: coherence.cache.v1.ExecuteRequest.keys:type_name -> coherence.cache.v1.KeysOrFilter
	11, // 7: coherence.cache.v1.MapListenerRequest.keyOrFilter:type_name -> coherence.cache.v1.KeyOrFilter
	2,  // 8: coherence.cache.v1.MapEventMessage.transformationState:type_name -> coherence.cache.v1.MapEventMessage.TransformationState
	9,  // [9:9] is the sub-list for method output_type
	9,  // [9:9] is the sub-list for method input_type
	9,  // [9:9] is the sub-list for extension type_name
	9,  // [9:9] is the sub-list for extension extendee
	0,  // [0:9] is the sub-list for field type_name
}

func init() { file_cache_service_messages_v1_proto_init() }
func file_cache_service_messages_v1_proto_init() {
	if File_cache_service_messages_v1_proto != nil {
		return
	}
	file_common_messages_v1_proto_init()
	file_cache_service_messages_v1_proto_msgTypes[0].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[1].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[3].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[4].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[6].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[7].OneofWrappers = []any{
		(*KeysOrFilter_Key)(nil),
		(*KeysOrFilter_Keys)(nil),
		(*KeysOrFilter_Filter)(nil),
	}
	file_cache_service_messages_v1_proto_msgTypes[8].OneofWrappers = []any{
		(*KeyOrFilter_Key)(nil),
		(*KeyOrFilter_Filter)(nil),
	}
	file_cache_service_messages_v1_proto_msgTypes[9].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[10].OneofWrappers = []any{}
	file_cache_service_messages_v1_proto_msgTypes[11].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_cache_service_messages_v1_proto_rawDesc), len(file_cache_service_messages_v1_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cache_service_messages_v1_proto_goTypes,
		DependencyIndexes: file_cache_service_messages_v1_proto_depIdxs,
		EnumInfos:         file_cache_service_messages_v1_proto_enumTypes,
		MessageInfos:      file_cache_service_messages_v1_proto_msgTypes,
	}.Build()
	File_cache_service_messages_v1_proto = out.File
	file_cache_service_messages_v1_proto_goTypes = nil
	file_cache_service_messages_v1_proto_depIdxs = nil
}
